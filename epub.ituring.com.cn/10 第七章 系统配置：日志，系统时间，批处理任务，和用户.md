#第七章 系统配置：日志，系统时间，批处理任务，和用户
&nbsp;![图像说明文字](/api/storage/getbykey/screenshow?key=15029c811aca8dafa075)

当你第一次看到/etc目录时，可能会感觉信息量太大。其中的大多数文件或多或少都对系统运行有影响，有的甚至非常关键。

本章我们介绍一些系统组件，它们使得用户级工具（参见`第二章`）能够访问系统的基础设施（参见`第四章`）。我们将着重介绍以下内容：

- 系统库为获得服务和用户信息而访问的配置文件
- 系统启动时运行的服务程序（有时称为守护进程，daemon）
- 用来更改服务程序和配置文件的配置工具
- 系统管理工具

本章不涉及网络相关的内容，因为那是一个相对独立的部分，我们将在`第九章`介绍。

##7.1 /etc目录结构

Linux系统的大部分系统配置文件都存放在/etc目录中。按照惯例，每个程序在这里都有一个或多个配置文件，Unix系统的程序数目很多，所以/etc目录也会越来越庞大。

这样带来了两个问题：一是很难找到要找的配置文件，维护起来也不方便。比如，要更改系统的日志配置，你需要编辑/etc/syslog.conf文件。但是你的更改可能会被随后的系统升级覆盖掉。

目前比较常见的方式是将系统配置文件放到/etc下的子目录，象我们介绍过的启动目录一样（Upstart的是/etc/init，systemd的是/etc/systemd）。虽然/etc目录下仍然会有一些零散的配置文件，如果你运行ls -F /etc查看的话，你会发现大部分配置文件都放到了子目录中。

为了解决配置文件被覆盖的问题，你可以将定制的配置放到子目录里的其他文件中，如：/etc/grub.d。

/etc中到底有哪些类型的配置文件呢？基本规律是针对系统的可定制的配置文件在/etc下，如：用户信息（/etc/passwd）和网络配置（/etc/network）。然而，应用程序细节相关的不在/etc中，如：系统用户界面的缺省配置。你会发现那些不可定制的系统配置文件存放在其他地方，比如预先打包的系统单元文件在/usr/lib/systemd中。

我们已经介绍过一些启动相关的配置文件。下面让我们来看一个具体的系统服务及其配置文件。

##7.2 系统日志

大多数系统程序将它们的日志信息输出到syslog服务。传统的syslogd守护进程等待消息的到来，根据它们的类型将它们输出到文件、屏幕、和其他地方，有的干脆忽略。

###7.2.1 系统日志

系统日志是系统中最重要的部分之一，如果系统出现你不清楚的错误，查看系统日志文件是第一选择。以下是日志文件示例：

```
Aug 19 17:59:48 duplex sshd[484]: Server listening on 0.0.0.0 port 22.
```

大多数Linux系统使用的是syslogd的一个新版本，叫做rsyslogd，它的功能不仅仅限于记录日志信息。比如，你还可以让它加载一个将日志信息写到数据库的模块。不过最简单的方式还是从/var/log目录开始。你看看其中的那些日志文件后，就能够了解它们来自哪里。

 /var/log目录中很多文件都不是由系统日志来维护的。要知道哪些日志属于rsyslogd，需要查看它们的配置文件。

###7.2.2 配置文件

rsyslog的基础配置文件是/etc/rsyslog.conf，你还会在其他地方发现另外一些配置文件，如：/etc/rsyslog.d。其内容包含传统的规则和rsyslog扩展。其中一条规则是任何以字符$开头的都是扩展。

 传统的规则包括一个选择符（selector）和一个操作（action），说明从哪里获得日志和将它们写到哪里，如下例所示：

<i>例7-1. syslog规则</i>

```
kern.*  /dev/console
*.info;authpriv.none➊   /var/log/messages
authpriv.*  /var/log/secure,root
mail.*  /var/log/maillog
cron.*  /var/log/cron
*.emerg *➋
local7.*    /var/log/boot.log
```
左边是选择符，表示要为哪种信息类型记录日志。右边是操作列表，表示要将日志写到哪里。`例7-1`中大部分的操作都是将日志写入文件，也有一些例外。例如：/dev/console表示系统控制台的一个特殊设备，root表示如果root用户登录的话，将消息发送给他，*代表发送消息给系统中的所有用户。你还可以使用@host将消息发送给网络上的其他主机。

####设施和优先级

选择符用来匹配日志信息的设施和优先级。设施是指消息的大致分类。（使用rsyslog.conf(5)在帮助手册中查看完整的设施列表）

设施的功能很容易通过它们的名称得知。例如，`例7-1`中的配置文件从kern，authpriv，mail，cron和local7这些设施中抓取日志信息。➋处的*号是一个通配符，表示从所有设施中获得输出。

设施后的.后面是优先级。由低到高分别是：debug，info，notice，warning，err，crit，alert和emerge。

<center>注解</center>

*要在rsyslog.conf中将日志消息从设施中排除，可以使用none作为优先级，如`例7-1`中➊所示。*

为选择符设置了优先级之后，rsyslogd将该优先级及其以上优先级的消息发送到指定目的地。也就是说，`例7-1`中➊处的*.info将抓取大部分日志消息并将它们写到/var/log/messages，因为info是一个相对较低的优先级。

####扩展语法

之前提到过，rsyslogd的语法扩展了传统的syslogd语法，它们通常以$开头，我们称之为指令。一个比较常用的扩展是让你加载其他的配置文件。rsyslog.conf中就包含这样的指令，让rsyslogd加载/etc/rsyslog.d目录中的所有.conf文件。

```
$IncludeConfig /etc/rsyslog.d/*.conf
```

大部分的指令都很好理解。比如以下涉及用户和权限的指令：

```
$FileOwner syslog
$FileGroup adm
$FileCreateMode 0640
$DirCreateMode 0755
$Umask 0022
```

<center>注解</center>

*还有一些rsyslogd配置文件扩展定义了输出模版和频道，你可以使用rsyslogd(5)来查看完整的帮助手册，不过它的Web文档更全面一些。*

####故障排除

测试系统日志最简单的方法之一是使用logger命令手工发送日志消息，如下所示：

$ **logger -p daemon.info something bad just happened**

rsyslogd不容易出错。出现问题大都是因为配置文件没有正确配置设施和优先级，因而没有获得想要抓取的日志信息，或者是由于磁盘空间不足。大多数系统会使用logrotate或者类似工具来自动清除/var/log中的文件，不过如果在短时间写入大量日志时还是会出现系统负载增加、磁盘空间用尽的情况。

<center>注解</center>

*rsyslogd抓取的日志不仅仅来自于系统各组件。我们在`第六章`介绍过systemd和Upstart抓取的启动日志消息，除此之外还有很多其他来源，比如Apache Web服务器，通常它有自己的存取和错误日志。你可以查看服务器配置来获得那些日志。*

####日志的过去和未来

syslog服务在不断演进。曾经出现过一个叫klogd的守护进程，负责为syslogd截获内核的日志消息。（这些日志可以使用dmesg命令查看）后来该功能被并入到了rsyslogd中。

毋庸置疑的是，Linux的系统日志功能会随着时间而改变。Unix系统日志从来就没有形成过一个标准，不过这种情况正在慢慢改变。

##7.3 用户管理文件

Unix系统支持多用户。用户对于内核而言只是一些数字（用户ID），因为用户名比数字容易记忆，所以用户一般都是用用户名（usernames或者login names）而非用户ID来管理系统。用户名只存在于用户空间，使用到用户名的应用程序在和内核通迅时，通常需要将用户名映射为用户ID。

###7.3.1 /etc/passwd文件

文本文件/etc/passwd中包含一一对应的用户名和用户ID。如下所示：

<i>例7-2. /etc/passwd中的用户列表</i>

```
root:x:0:0:Superuser:/root:/bin/sh
daemon:*:1:1:daemon:/usr/sbin:/bin/sh
bin:*:2:2:bin:/bin:/bin/sh
sys:*:3:3:sys:/dev:/bin/sh
nobody:*:65534:65534:nobody:/home:/bin/false
juser:x:3119:1000:J. Random User:/home/juser:/bin/bash
beazley:x:143:1000:David Beazley:/home/beazley:/bin/bash
```

每一行代表一个用户，一共有7列，通过冒号:分隔，它们依次是：

- 登录名（Login name）
- 经过加密的用户密码（Password）。大部分Linux系统都不在passwd中存放实际的用户密码，而是将密码存放在shadow文件中（参见`7.3.3 /etc/shadow文件`）。shadow文件的格式和passwd类似，不过普通用户没有访问权限。passwd和shadow文件中的第2列是经过加密的密码，是一些象d1CVEWiB/oppc这样的字符，读起来很费劲。（Unix不明文存储密码）
第2列中的x代表加密过的密码存放在shadow文件中。*代表用户不能登录，如果为空（象::这样），则表示登录不需要密码。（绝对不要将普通用户的该列设置为空）
- 用户ID（User ID，UID）是用户在内核中的标识。同一个用户ID可以出现在两行中，不过这样做比较容易产生混淆，程序在处理时也需要将它们合并起来。用户ID必须唯一。
- 用户组ID（Group ID，GID）是/etc/group文件中的某个ID号。用户组定义了文件权限及其他。该列也称为用户的基本组（primary group）。
- 用户的真实名称（Real name，通常称为GECOS列）。有时候其中会有逗号，用来分隔房间和电话号码。
- 用户的根目录（Home directory）。
- 用户使用的命令行（Shell），即用户运行终端的程序。

`图7-1`标识出了`例7-2`中条目的各列。

![图像说明文字](/api/storage/getbykey/screenshow?key=1502e8dd24e07f1543b2)
<center><i>图7-1. passwd文件中的条目</i></center>

/etc/passwd文件有严格的语法规则，不允许注释和空行。

<center>注解</center>

*用户在/etc/passwd中的对应行和其根目录统称为用户账号。*

###7.3.2 特殊用户

在/etc/passwd中有一些特殊用户。超级用户（root）的UID和GID固定为0，如`例7-2`所示。有一些用户如daemon没有登录权限。nobody用户的权限最小。一些进程在nobody名下运行，因为它没有任何写权限。

无法登录的用户我们称为伪用户（pseudo-users）。虽然无法登录系统，但是系统可以使用它们来运行一些进程。nobody这样的伪用户的目的是为了安全方面考虑。

###7.3.3 /etc/shadow文件

Linux中的影子密码文件（/etc/shadow）包含用户验证信息，包括经过加密的密码和密码过期日期，和/etc/passwd文件中的用户相对应。

Shadow文件为密码存储提供了一种更灵活（同时也更安全）的方法。它包括了一些程序库和工具，后来很快被PAM替代（参考`7.10 PAM`）。PAM使用/etc/shadow文件，而非象/etc/login.defs这样的配置文件。

###7.3.4 用户和密码管理

普通用户使用passwd命令来更改密码。passwd不仅可以更改用户密码，你还可以使用-f选项来更改用户名，-s选项来更改shell（/etc/shells中有shell列表）。（你还可以使用chfn和chsh来更改用户名和shell）passwd命令是一个suid-root程序，只有超级用户能够编辑/etc/passwd文件。

####使用超级用户来更改/etc/passwd

/etc/passwd是纯文本文件，超级用户可以使用任何文本编辑器来编辑它。要添加用户，只需加上一行并且为用户创建一个根目录即可，要删除用户则反之。不过通常我们使用vipw来编辑/etc/passwd文件，它更为安全，会在你编辑时备份和锁定文件。你还可以使用vipw -s来编辑/etc/shadow文件（虽然你可能永远不需要用到）。

很多人不愿意直接编辑passwd文件，因为很容易把文件搞乱。使用另外的终端命令或者图形界面（GUI）更为方便和安全。

如可以使用超级用户运行passwd user可以设置用户密码。adduser和userdel可以添加和删除用户。

###7.3.5 用户组

用户组用可以将文件访问权设定给某些用户，而使其他用户无权访问。你可以为某组用户设置读写位，从而排除其他的用户。在多名用户共享一台主机的时候，用户组很有用，然而现在我们很少在主机上共享文件了。

/etc/group文件中包含了用户组ID（类似/etc/passwd文件中的ID）。如`例7-3`所示：

<i>例7-3. /etc/group文件样例</i>

```
root:*:0:juser
daemon:*:1:
bin:*:2:
sys:*:3:
adm:*:4:
disk:*:6:juser,beazley
nogroup:*:65534:
user:*:1000:
```

和/etc/passwd文件一样，/etc/group中的每一行有多列，由冒号分隔。从左到右是：

- 用户组名（Group name），运行如ls -l这样的命令时可以看到
- 用户组密码（Password），很少也不该被使用（使用sudo替代）。可以设置为*或者其他缺省值。
- 用户组ID（Group ID），必须是一个唯一的数字。GID出现在/etc/passwd文件的用户组列中。
- 属于该组的用户列表（Additional members），该列是可选项，passwd文件中的用户组ID列也定义了用户属于哪个用户组。

`图7-2`显示了用户组文件中的各列：

![图像说明文字](/api/storage/getbykey/screenshow?key=15026391df7e60f61668)
<center><i>图7-2. group文件中的条目</i></center>

你可以使用group命令来查看你所属的用户组。

<center>注解</center>

*Linux通常会为每个新加入的用户创建一个新的用户组，用户组名和用户名相同。*

##7.4 getty和login

getty连接到终端并且在其上显示登录提示符。大多数Linux系统中的getty程序很简单，仅仅是在虚拟终端上显示提示符。它可以使用在管道命令中，如下所示：

￼$ **ps ao args | grep getty**

```
/sbin/getty 38400 tty1
```

本例中38400是波特率。有些getty不需要该设置。（虚拟终端会忽略此设置，这只是为了和连接串行口的那些程序兼容）

输入用户名后，getty调用login程序提示你输入密码。如果输入的密码正确，login调用你的shell（使用exec()）。否则你会得到“登录错误”提示信息。

现在你了解了getty和login，虽然你可能不需要配置和更改它们。实际上你使用它们的机会可能不多，因为现在用户大都通过图形界面（如gdm）或者远程登录（如SSH）。login的用户验证由PAM来处理（参考`7.10 PAM`）。

##7.5 设置时间

Unix系统的运行依赖精确的计时。内核负责维护系统时钟（system clock），你可以使用date命令来查看，还可以用它设置时间，不过并不推荐这样做，因为设置的时间有可能不精准，你的系统时间应该尽可能的精准。

计算机硬件有一个使用电池的时钟（real-time clock，RTC）。RTC并不是最精准的，但是聊胜于无。内核通常在启动时使用RTC来设置时间，你可以使用hwclock命令将系统时间重新设置为硬件系统的当前时间。最好将你的硬件时钟设置为UTC（Universal Coordinated Time），这样可以避免不同时区和夏令时带来的问题。你可以使用以下命令将内核的UTC时钟设置为RTC：

\# **hwclock --hctosys --utc**

不过内核在计时方面还不如RTC，因为Unix系统启动一次经常持续运行数月甚至数年，所以容易产生时间误差（time drift）。这个误差是指系统时间的实际时间（通常由原子时钟等精确时钟产生）之差。

不要试图使用hwclock来修复时间误差，因为这会影响那些基于时间的系统事件。你可以运行adjtimex来更新系统时钟，不过最好的办法是使用守护进程来使你的系统时间和网络上的时间保持同步（参见`7.5.2 网络时间`）。

###7.5.1 内核时间和时区

内核将当前的系统时间显示为以秒为单位的一串数字，自UTC时间1970年1月1日12:00时起开始。你可以使用以下命令来查看：

$ **date +%s**

为了易读性，用户空间程序会将这组数字转换为本地时间，并且将夏令时和其他因素都考虑在内（比如印第安纳州时间）。文件/etc/localtime（其是二进制文件）用来控制本地时区。

时区信息在/usr/share/zoneinfo文件中，其中包含了时区及其别名等信息。如果要手工设置时区，可以将/usr/share/zoneinfo中的某个文件拷贝到/etc/localtime（或者创建一个符号链接），或者使用系统自带的时区工具。（你可以使用tzselect命令寻找时区文件）

如果要为shell会话设置时区，可以将TZ环境变量设置为/usr/share/zoneinfo中的某个文件名，如下所示：

$ **export TZ=US/Central**

$ **date**

和其他环境变量一样，你也可以只为某条命令执行时设置时区，如下：

$ **TZ=US/Central date**

###7.5.2 网络时间

如果你的主机连接到Internet，你可以运行网络时间协议（Network Time Protocol, NTP）守护进程来更新时间。很多Linux系统自带NTP守护进程，但是不一定默认开启。你可以安装ntpd包来运行它。

如果你想做一些手工配置，可以参考NTP网站 [http://www.ntp.org](http://www.ntp.org/)，如果你想偷点懒也没关系，下面是简要的步骤：

1. 从你的ISP或者ntp.org获得离你最近的NTP服务器。
2. 将该服务器加入/etc/ntpd.conf文件。
3. 在启动时运行ntpdate server。
4. 在ntpdate命令之后运行ntpd。

如果你的主机没有Internet连接，你可以使用chronyd守护进程在离线状态下维护系统时间。

在系统重启时，你还可以根据网络时间来设置系统的硬件时钟。（很多Linux系统会自动这样做）使用ntpdate（或者ntpd）从网络设置系统时间，然后运行我们在前面注释中介绍过的命令：

\# **hwclock --systohc –-utc**

##7.6 使用cron来调度日常任务

Unix的cron服务能够按照日程安排来重复运行任务。cron对多数富有经验的系统管理员来说非常重要，它可以完成很多自动化的系统维护工作。比如，它运行日志文件的替换工具来确保旧的日志文件被删除以腾出磁盘空间。建议你要掌握cron的使用方法，这对你会很有帮助。

你可以使用cron在任何时间运行任何程序。通过cron运行的程序我们称为cron任务。要添加一个cron任务，可以在crontab文件中加入一行，通常通过crontab来完成。例如，你要将/home/juser/bin/spmake命令安排在每天的9:15AM运行，可以加入以下一行：

```
15 09 * * * /home/juser/bin/spmake
```

最开始的5列用空格分隔，设定任务运行的时间（参见`图7-3`），它们分别是：

- Minute 分钟（0～59），上例中是15。
- Hour 小时（0～23），上例中是9。
- Day of month 天（1～31）。
- Month 月（1～12）。
- Day of week 星期（0～7），0和7代表周日。

![图像说明文字](/api/storage/getbykey/screenshow?key=1502863a1e48be54598a)
<center><i>图7-3. crontab文件中的条目</i></center>

表示匹配所有值。上例中spmake每天都运行，因为天、月、星期等列的值都是*，代表每天，每月，一周内的每一天。

如果只想在每个月的14号运行，可以使用下面这行设置：

```
15 09 14 * * /home/juser/bin/spmake
```

每一列可以有多个值。例如，要在每月5号和14号运行程序，可以将第三列设置为5,14：

```
15 09 5,14 * * /home/juser/bin/spmake
```

<center>注解</center>

*如果cron任务产生标准输出、错误、或者非正常退出，你会收到一封邮件通知。如果你觉得邮件太麻烦，可以将输出结果重定向到/dev/null或者日志文件中。*

帮助手册crontab(5)为我们提供了有关crontab的详细信息。

###7.6.1 安装Crontab文件

每个用户可以用自己的crontab文件，所以系统中经常会有很多个crontab，通常保存在/var/spool/cron/crontabs目录中。普通用户对该目录没有写权限，crontab命令负责安装、查看、编辑和删除用户的crontab。

安装crontab最简便的方法是将crontab条目放入一个文件（如：file），然后运行crontab file命令将该文件安装为你的crontab。crontab命令会检查文件的格式，确保没有错误。你可以使用crontab -l列出你的cron任务。使用crontab -r删除crontab文件。

然而当你第一次创建了crontab文件后，后续使用临时文件来进行更改会比较麻烦。你可以使用crontab -e命令来更改并安装的crontab。如果有错误，crontab命令会提示是否重新编辑。

###7.6.2 系统crontab文件

Linux系统通常使用/etc/crontab文件来安排系统任务的运行，而不是使用超级用户的crontab。不要使用crontab命令来编辑该文件，因为它有一个额外的列来设置运行任务的用户。例如下面这一行设置，任务在6:42AM由root（➊处）用户运行：

```
42 6 * * * root➊ /usr/local/bin/cleansystem > /dev/null 2>&1
```

<center>注解</center>

*一些系统将系统crontab文件存放在/etc/cron.d目录中。它们的文件名也许不同，不过内容格式和/etc/crontab一样。*

###7.6.3 cron的未来

cron工具是Linux系统中历史最长的组件之一，大约有几十年了，甚至在Linux出现之前就已经存在，它的文件格式一直以来基本上没有改变。由于它实在是太过于老旧，人们正在想办法替换它。

它的替代者实际上是新版本的init的一部分。对于systemd来说是计时器单元（timer units）。对于Upstart来说是重复产生事件来触发任务。总之它们都可能够以任何用户的名义运行任务，并且支持诸如定制日志这样的便利。

然而实际上目前的systemd和Upstart都还不具备cron的全部功能。而且，就算它们具备和所有功能，还要考虑向后兼容性，要能够支持那些依赖于cron的系统。从这个意义上说，cron还不会这么快被替代。

##7.7 使用at进行一次性任务调度

要在将来的某一时刻一次性运行任务，如果不使用cron的话，可以使用at服务。例如要在10:30PM运行myjob，可以使用以下命令：

$ **at 22:30**

at> **myjob**

使用CTRL-D结束输入。（at从标准输入读取命令）

要检查任务是否已经被设定，可以使用atq。要删除任务，使用atrm。你还可以使用这样的日期DD.MM.YY格式将任务设置为将来某一时刻运行，如：at 22:30 30.09.15。

关于at命令差不多就这么些内容。虽然它不太常用，不过在某些场景下比较有用，比如让系统在将来某个时刻关闭。

##7.8 了解用户ID和用户切换

我们已经介绍过，sudo和su这样的setuid程序允许你切换用户，login这样的系统组件负责控制用户访问。你或许想了解它们的工作原理，以及内核在用户切换中所起的作用。

更改用户ID有两种方式，均由内核负责完成。第一种是运行setuid程序，我们在`2.17 文件模式和权限`一节中介绍过。第二种是通过setuid()系统调用，该系统调用有很多不同版本，用来处理和进程关联的所有用户ID，我们将在`7.8.1 进程归属，有效UID，实际UID，和已保存UID`一节中详细介绍。

内核负责为进程制订规则，规定哪些能做和不能做，下面是三个基本规则：

- 以root（userid 0）身份运行的进程可以调用setuid()来切换为任何用户。
- 没有以root身份运行的进程在调用setuid()时有一些限制，大多数情况下不能调用setuid()。
- 任何进程，只要有足够的文件访问权限，都可以运行setuid程序。

<center>注解</center>

*用户切换并不涉及用户名和用户密码。这是用户空间的概念，我们在`7.3.1 /etc/passwd文件`一节中介绍过。我们将在`7.9.1 为用户信息使用库`一节中详细介绍。*

###7.8.1 进程归属，有效UID，实际UID，和已保存UID

到目前为止我们有关用户ID的内容都是简化过的。实际上每个进程都有超过一个用户ID。我们提到过的有效UID（effective user ID, euid）设定了进程的访问权限。另外还有一个UID时实际UID（real user ID, ruid），是实际启动进程的UID。当你运行setuid程序时，Linux将有效UID设置为程序文件的拥有者，同时将实际UID设置为你的UID。

有效UID和实际UID之间的区别很模糊，以至于很多文档中有关进程归属的内容都是不正确的。

我们可以将有效UID看作执行者（actor），实际UID看作所有者（owner）。实际UID是可以于进程进行交互的那个用户，可以终止进程，向进程发送信号。例如，如果用户A以用户B的名义启动了一个新进程（基于setuid权限），用户A仍然是该进程的所有者，并且可以终止该进程。

在Linux系统中，大多数进程的有效UID和实际UID是相同的。ps和其他系统诊断命令默认显示有效UID。可以使用以下命令来查看有效UID和实际UID：

$ **ps -eo pid,euser,ruser,comm**

如果想要两者有不同的值，可以为sleep命令创建一个setuid拷贝，运行一段时间，在其结束前使用ps命令在另一个终端窗口查看它的信息。

除了有效UID和实际UID外，还有一个已保存UID（saved user ID）。进程在运行过程中可以从有效UID切换到实际UID和已保存UID。（实际上Linux还有另外一个UID：文件系统UID，file system user ID，fsuid，很少用到，代表访问文件系统的用户）

####Setuid程序

实际UID可能会和我们以往的理解有冲突。我们也许会有疑问，为什么要经常和不同的用户打交道？举个例子，我们使用sudo启动了一个进程，如果要终止它，我们仍然需要sudo，而无法使用其他用户。这时候实际UID却是你，如果你对该程序文件有所有权的话。

因此sudo和其他setuid程序会使用setuid()这样的系统调用来显式地更改有效UID和实际UID。这样做是为了避免一些由于各UID不匹配导致的副作用和权限问题。

<center>注解</center>

*如果你对用户ID切换的细节和规则感兴趣，可以使用setuid(2)查看帮助手册，还可以参考SEE ALSO部分列出的其他帮助手册。该主题涉及很多针对不同情况的系统调用。*

许多程序不喜欢它们的实际UID是root。要防止sudo更改实际UID，可以将下面一行加入你的/etc/sudoers文件（请注意使用root运行程序可能带来的副作用）：

```
Defaults     stay_setuid
```

####相关安全性

因为Linux内核通过setuid程序和相关系统调用来处理用户切换（以及相关的文件存取权限），系统管理员和开发人员必须特别注意以下两点：

- 有setuid权限的程序
- 这些程序所执行的功能

如果你创建了一个bash shell的拷贝，setuid为root，普通用户就可以运行它来获得整个系统的控制权。就这么简单，就这么任性。另外，setuid为root的程序中的bug也有可能为系统带来风险。攻击Linux系统的常见方式之一就是利用那些以root名义运行的程序的漏斗，这样的例子数不胜数。

由于手段繁多，防止系统攻击是一个复杂的主题，涉及很多方面。其中最有效的方式之一是强制使用用户名和密码进行验证。

##7.9 用户标识和认证

多用户系统必须支持基本的用户标识（identification）和认证（authentication）。用户标识判定用户的身份，即是哪一位用户。用户认证让用户来证明自己就是其声称的那位用户。用户授权（authorization）限定用户的权限。

对于用户标识，Linux内核通过用户ID来管理进程和文件的权限。对于用户认证，Linux内核控制如何执行setuid，以及如何让用户ID执行setuid()系统调用来切换用户。然而内核对于运行在用户空间中的所有用户认证相关事宜却一无所知，比如：用户名和用户密码等等。

我们在`7.3.1 /etc/passwd文件`一节中介绍过用户ID和密码的对应关系，现在我们来介绍用户进程如何使用这些对应关系。我们先看一个简化的例子，用户进程需要知道它的用户名（即其有效UID对应的用户名）。在传统的Unix系统中，进程通过以下步骤获得用户名：

1. 进程使用geteuid()系统调用从内核处获得它的有效UID。
2. 进程打开并浏览/etc/passwd文件。
3. 进程从/etc/passwd文件中逐行读取内容。如果没有可读取的内容，则整个过程失败。
4. 进程将整行内容解析为字段（就是用冒号分隔的列）。第三列即是用户ID。
5. 进程将第4步中获得的用户ID和第1步中的用户ID进行匹配，如果匹配成功，则该行的第1列即为要找的用户名，整个过程结束。
6. 否则进程返回第3步继续。

实际上上述过程复杂得多。

###7.9.1 为用户信息使用库

如果上述过程要让每个有此需求的开发人员自己实现的话，整个系统会变得支离破碎，错误百出，难以维护。万幸的是，一旦你从geteuid()获得用户ID，你需要做的只是调用象getpwuid()这样的标准库函数来获得用户名。（详细使用方法可参考帮助手册）

有了共享的标准库，你可以自己对需要的功能做一系列的加工而不会影响到其他程序。比如，你可以不用/etc/passwd，而是使用LDAP这样的网络服务来获得用户名。

上述方法对于通过用户ID得到对应的用户名来说行得通，但是对于密码来说就不行了。`7.3.1 /etc/passwd文件`一节中介绍过，一般来说/etc/passwd中的是经过加密的密码，如果你要验证用户输入的密码，你需要将用户输入的密码加密，然后和/etc/passwd文件中的密码进行比对。

这样的方式有下面几个局限：

- 系统对于加密协议并没有一个统一标准
- 前提是你需要有对加密密码的访问权限
- 前提是每当用户需要访问资源的时候，你都要让用户输入用名和密码（这会让人抓狂）。
- 前提是你使用密码。如果你使用的是一次性token，智能卡，生物识别技术，活着其他形式的验证，你需要自己加入对它们的支持。

由于上述的一些局限，也促成了影子密码机制开发，我们在`7.3.3 /etc/shadow文件`一节中介绍过，它就是用来建立系统层面的密码配置标准。不过上述大部分的问题促成了PAM解决方案的出现。

##7.10 PAM

为了提高用户验证的灵活性，Sun Microsystems公司在1995年提出了一个新的标准，可插入验证模块（Pluggable Authentiation Modules，PAM），它是一个共享的验证库（Open Source Software Foundation RFC 86.0, October 1995）。进行用户验证的时候，用户被提交给PAM来处理。这样比较容易加入新的验证方式和技术，比如：两段式验证（two-factor）和物理钥匙。除了对验证机制的支持，PAM还提供一些有限的验证控制服务（如可以为某些用户禁止cron这样的服务）。

因为用户验证的应用场景很多，PAM使用了一系列可以动态加载的验证模块。每个模块负责一个具体的任务，比如：pam_unix.so模块负责检查用户密码。

这样的任务很不简单。编程接口都很复杂，PAM看起来也没有能够解决所有的问题。无论怎样，Linux系统中涉及用户验证的程序基本上都是使用PAM，大部分Linux系统也是使用PAM。因为PAM是基于Unix现有的验证API，所以在集成PAM支持的时候只需少量的额外工作即可。

###7.10.1 PAM配置

我们将通过PAM的配置来了解PAM的工作原理。PAM配置文件通畅存放在/etc/pam.d目录（在较老的系统中有可能是/etc/pam.conf文件）。目录中文件很多，可能会让人抓不着头绪。一些文件名应该会包含一些你熟知的系统名称，比如cron和passwd。

由于这些配置文件在不同的Linux系统上各异，我们很难找到一个通用的例子。我们以chsh（change shell）的配置文件中的一行为例：

```
auth requisite pam_shells.so
```

该行表示用户的shell必须在/etc/shells中，以便能够与chsh进行验证。配置文件中每一行有三列：功能类型，控制参数和模块。以下是它们代表的意思：

- **功能类型（function type）**，指定用户应用程序请求PAM执行的任务。本例中是auth，即用户验证。
- **控制参数（control argument）**，指定PAM在成功执行任务或者任务执行失败后的操作（本例中为requisite），我们稍后详细介绍。
- **模块（module）**，指定运行的验证模块。本例中pam_shells.so模块检查用户shell是否在/etc/shells中。

####功能类型

PAM能够执行以下四类功能：

- **auth** 用户验证（验证用户身份）。
- **account** 检查用户账号状态（例如用户是否对某一操作有权限）。
- **session** 仅在用户当前进程内执行（例如显示当日的消息）。
- **password** 更改用户密码和其他验证信息。

功能类型和模块用来定义PAM执行的操作。模块可以有多个功能类型，当我们查看配置行时，需要结合功能类型和模块来确定该行的功能。比如，pam_unix.so模块在执行auth时检查密码，但是在执行password时却是设置密码。

####控制参数和入栈规则

PAM的一个重要特性是它的配置行中使用stack定义的规则，你可以为执行的操作定义一些规则。这也凸显了控制参数的重要性，某一行任务执行的成败会影响到后面的行甚至整个任务执行的成败。

控制参数有两类：简单语法和高级语法。简单语法的控制参数主要是以下三种：

- **sufficient** 如果规则执行成功，用户验证即成功，PAM忽略其他规则。如果规则执行失败，PAM继续执行其他规则。
- **requisite** 如果规则执行成功，PAM继续执行其他规则。如果规则执行失败，用户验证即失败，PAM忽略其他规则。
- **required** 如果规则执行陈功，PAM继续执行其他规则。如果规则执行失败，PAM继续其他规则，但是无论其他规则执行结果如何，最终的验证将失败。

让我们继续上例，下面是chsh验证的一个堆栈实例：

```
auth sufficient pam_rootok.so 
auth requisite pam_shells.so
auth sufficient pam_unix.so 
auth required pam_deny.so
```

当chsh请求PAM执行用户验证时，根据以上配置，PAM执行以下步骤（见`图7-4`）：

1. pam_rootok.so模块检查进行验证的用户是否是root。如果是的话则立即验证通过并且忽略其他后续验证。这是因为控制参数sufficient，表示当前操作执行成功即可，PAM立即通知chsh验证成功。否则继续执行步骤2。
2. pam_shell.so模块检查用户的shell是否在/etc/shells中。如果不是的话，模块返回失败，requisite控制参数表示PAM应立即通知chsh验证失败，并忽略其他后续验证。如果shell在/etc/shells中，模块返回验证成功，并且根据控制参数required继续执行步骤3。
3. pam_unix.so模块要求用户输入密码并检查。控制参数为sufficient，意思是该模块验证通过后PAM即向chsh报告验证成功，如果输入密码不正确，PAM继续步骤4。
4. pam_deny.so模块总是返回失败，由于控制参数为required，PAM向chsh返回验证失败。在没有其他规则的情况下，这是默认的操作。（请注意required控制参数并不导致PAM立即失败，其还会继续后续的操作，但是最终还是返回验证失败）

![图像说明文字](/api/storage/getbykey/screenshow?key=1502faf12aa4ea2c53fa)
<center><i>图7-4. PAM规则执行流程</i></center>

>图片文字翻译开始

>PAM start: request to authenticate PAM启动：请求验证

>pam_rootok.so: Is root trying to authenticate? pam_rootok.so:root是否正在尝试验证？

>pam_shells.so: Is shell in /etc/shells? shell是否在/etc/shells中？

>pam_unix.so: Did user enter correct password? pam_unix.so：用户输入的密码是否正确？

>pam_deny.so: Always fail pam_deny.so：总是失败

>Authentication failed 验证失败

>Authentication successful 验证成功

>图片文字翻译结束

<center>注解</center>

*在讨论PAM的时候，不要将功能（function）和操作（action）混淆起来。功能是广义上的目标，即用户请求PAM执行的操作（诸如用户验证）。操作是PAM为了达到目标执行的某个具体任务。你只需要记住，用户应用程序首先执行功能，然后PAM负责执行相关操作。*

高级语法的控制参数使用方括号（[]）表示，让你能够根据模块的返回值（不仅仅是成功和失败两种）手动定义相应的操作。详情可以查看pam.conf(5)帮助文档，了解了简单语法控制参数后，高级语法控制参数就不是问题了。

####模块参数

PAM模块能够在模块名后带参数。在pam_unix.so模块中你经常能够看到类似下面的内容：

```
auth sufficient pam_unix.so nullok
```

参数nullok表示用户可以不需要密码（默认值是用户如果没有密码则验证失败）。

###7.10.2 关于PAM的一些注解

由于控制流和模块参数语法，使得PAM配置语法具备了编程语言的某些特征和功能。目前我们仅仅是介绍了皮毛，下面是更多关于PAM的介绍：

- 可以使用man -k pam_(请注意此处的下划线)来列出系统中的PAM模块。要查看这些模块的存放位置可能会很难，你可以用locate unix_pam.so命令试试运气。
- 帮助手册中有每个模块相关功能和参数的详细信息。
- 很多Linux系统会自动生成一些PAM配置文件，所以尽量不要在/etc/pam.d目录中直接对它们进行更改。在做更改之前请阅读/etc/pam.d文件中的注释信息，如果它们是由系统生成的文件，注释中会对来源加以说明。
- /etc/pam.d/other配置文件中包含默认配置，用于那些没有自己的配置文件的应用程序。默认配置往往是拒绝所有的验证。
- 在PAM配置文件中包含其他配置文件的方法有很多种。@include语法加载整个配置文件，你也可以使用控制参数来加载配置文件的特定功能。不同的系统方式不同。
- PAM配置不以模块参数结束。一些模块可以访问/etc/security中的其他文件，通常用来配置针对某个用户的特定限制。

###7.10.3 PAM和密码

由于Linux密码校验近年来的不断发展，留下了很多密码配置包，有些时候容易产生混淆。首先是/etc/login.defs这个文件，它是最初影子密码的配置文件。其中包含了加密算法的信息，不过使用PAM的新版本系统很少使用它了，因为PAM配置中自己包含了这些信息。所以，/etc/login.defs中的加密算法必须和PAM配置中的相匹配，以防万一有的应用程序不支持PAM。

PAM是从哪里获得密码加密信息呢？PAM处理密码的方式有两种：通过auth功能（用来校验密码）和password功能（用来设置密码）。查看密码设置参数很容易，最简单的方式是使用grep，如下所示：

$ **grep password.*unix /etc/pam.d/* **

匹配的行中会包含pam_unix.so，象下面这样：

```
password sufficient pam_unix.so obscure sha512
```

参数obscure和sha512告诉PAM在设置密码时执行什么操作。首先，PAM检查密码是否足够复杂（也就是说，新密码不能和老密码太过相似，后者太常用），然后PAM使用SHA512算法来加密新密码。

这支在用户设置密码时生效，而不是在PAM校验密码时。PAM是怎样知道在用户验证时使用哪个算法呢？配置信息中没有这方面的信息，对于pam_unix.so的auth功能来说，没有针对加密信息的参数，帮助手册里也没有。

看起来pam_unix.so仅仅是靠猜测，通常是通过libcrypt库来尝试找出使用的那个算法。所以你通常不用太担心密码校验加密算法。

##7.11 前瞻

至此我们已经到达的全书的一半，介绍了Linux系统的很多关键组成部分。特别是关于日志和用户的内容，让你了解到Linux系统是如何将服务和任务分解为小而独立的部分并且仍然能够在上下文中相互交互。

本章主要是用户空间方面的内容，我们需要对用户空间进程和它们消耗资源有一个新的认识，因此让我们进入`第八章`来看看内核。
