#第八章 深入进程和资源配置
&nbsp;![图像说明文字](/api/storage/getbykey/screenshow?key=15029c811aca8dafa075)

本章我们将深入介绍进程之间的关系，内核和系统资源。计算机硬件资源主要有三种：CPU，内存，和I/O。进程为获得这些资源相互竞争，内核则负责公平地分配资源。内核本身也是一种软件资源，进程通过它来创建新的进程，以及和其他进程通讯。

本章介绍的工具当中，有很多涉及性能监控，在你试图找出系统变慢的原因时会非常有帮助。然而我们不需要过多关注系统性能，优化已经工作良好的系统经常是浪费时间。我们应该更多地了解这些工具的功能，同时在此过程中我们会对内核有更深入的了解。

##8.1 进程跟踪

我们在`2.16 查看和操纵进程`一节中介绍过如何使用ps命令查看系统中运行的进程。ps命令列出当前运行的进程，但是无法提供进程随时间变化的情况。因而你无法得知哪个进程使用了过多的CPU时间和内存。

在这方面top命令比ps命令更有用些，因为它能够显示系统的当前状态，还有ps命令显示的一些信息，并且每秒更新一次信息。最重要的是top命令将系统中最活跃的进程（即当前消耗CPU时间最多的那些进程）显示在最上方。

你可以向top命令发送键盘命令。下面是一些比较重要的命令：￼


| Spacebar | Updates the display immediately. |
|-|-|
|M | Sorts by current resident memory usage. |
|T | Sorts by total (cumulative) CPU usage. |
|P | Sorts by current CPU usage (the default). |
|u | Displays only one user’s processes. |
|f | Selects different statistics to display. |
|? | Displays a usage summary for all top commands. |

Linux中另外还有两个类似于top的工具，提供更详细的信息和更丰富的功能，它们是atop和htop。还有另外一些工具提供额外的功能，比如htop命令包含一些lsof命令的功能，lsof我们将在下节介绍。

##8.2 使用lsof查看打开的文件

lsof命令列出打开的文件以及使用它们的进程。由于Unix系统中大量使用文件，所以lsof在系统排错方面是最有用的命令之一。lsof不仅仅显示常规文件，还显示网络资源，动态库，管道等等。

###8.2.1 lsof输出

lsof的输出结果通常信息量很大，见下面的例子，其中有init和vi打开的文件：

$ **lsof**

```
COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME
init 1 root cwd DIR 8,1 4096 2 /
init 1 root rtd DIR 8,1 4096 2 /
init 1 root mem REG 8, 47040 9705817 /lib/i386-linux-gnu/libnss_files-2.15.so
init 1 root mem REG 8,1 42652 9705821 /lib/i386-linux-gnu/libnss_nis-2.15.so
init 1 root mem REG 8,1 92016 9705833 /lib/i386-linux-gnu/libnsl-2.15.so
--snip--
vi 22728 juser cwd DIR 8,1 4096 14945078 /home/juser/w/c
vi 22728 juser 4u REG 8,1 1288 1056519 /home/juser/w/c/f
--snip--
```

其中包含以下几列：

- **COMMAND**，打开文件的进程对应的命令名。
- **PIM**，进程ID。
- **USER**，运行进程的用户。
- **FD**，该列包含两种元素。本例中FD列显示文件的作用。该列还能够显示打开文件的描述符，文件描述符是一个数字，进程通过它使用系统库和内核来进行文件标识和操作。
- **TYPE**，文件类型（如：常规文件，目录，套接字等）。
- **DEVICE**，包含该文件的设备的最大最小代码。
- **SIZE**，文件大小。
- **NODE**，文件的inode编号。
- **NAME**，文件名。

以上各列所有可能的值可以在帮助手册lsof(1)可以找到，不过输出结果应该很清楚了。例如，FD列中使用加粗字体标出cwd的那些行，它们显示当前进程的工作目录。另一个例子是最后一行，它显示用户正在使用vi编辑的文件。

###8.2.2 lsof的使用

运行lsof有两种基本方式：
- 输出完整的结果，然后将输出结果通过管道用命令less显示，然后在其中搜索你想要的内容。由于输出结果信息量很大，该方法可能会花点时间。
- 使用命令行选项来过滤lsof的输出结果。

你可以使用命令行选项将文件名作为参数，让lsof只显示和参数匹配的条目。例如，下面的命令显示/usr目录中的所有打开文件：

$ **lsof /usr**

根据进程ID列出打开文件，使用以下命令：

$ **lsof -p pid**

你可以运行lsof -h查看所有的选项。大部分选项和输出格式有关。（请参考`第十章`中关于lsof网络特性的介绍）

<center>注解</center>

*lsof和内核信息密切相关。如果你升级内核时没有按常规升级系统的其他部分，你可能需要升级lsof。如果你同时升级了内核和lsof，新的lsof可能需要你重新启动新内核以后才能够正常工作。*

##8.3 跟踪程序执行和系统调用

到目前为止我们介绍的工具都是针对运行中的进程。然而有时候你的程序可能在系统启动后马上就终止了，这时你可能会一头雾水，lsof命令也不管用了。实际上使用lsof查看执行失败的进程非常困难。

strace（trace系统调用）和ltrace（trace系统库）命令能够帮助你了解程序试图执行哪些操作。它们的输出信息量都很大，不过一旦你确定了查找的范围，有很多工具可以帮助你定位需要的信息。

###8.3.1 strace

之前介绍过，系统调用是用户空间请求内存执行的经过授权的操作，诸如打开文件读取数据等等。strace能够显示进程涉及的所有系统调用。可以通过下面的命令查看：

$ **strace cat /dev/null**

在`第一章`中我们介绍过，进程调用fork()系统调用来从自身创建出一个新的进程分支（即自己的一个拷贝），然后新的进程调用exec()系统调用集来启动和运行新的程序。strace命令在fork()系统调用之后开始监控新创建的进程（源进程的拷贝）。因而该命令输出结果的一开始几行应该显示execve()的执行情况，随后是内存初始化系统调用brk()，如下所示：

```
execve("/bin/cat", ["cat", "/dev/null"], [/* 58 vars */]) = 0 brk(0) = 0x9b65000
```

输出的后续部分涉及共享库的加载。除非你想要知道加载共享库的细节，否则你可以忽略这些信息。

```
access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb77b5000
access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
--snip--
open("/lib/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200^\1"...,
1024)= 1024
```

除此之外，你可以跳过输出结果中的mmap，直到下面的部分：

```
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 6), ...}) = 0
open("/dev/null", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
fadvise64_64(3, 0, 0, POSIX_FADV_SEQUENTIAL)= 0
read(3,"", 32768) = 0
close(3) = 0
close(1) = 0
close(2) = 0 
exit_group(0) = ?
```

这部分内容显示正在运行中的命令。首先我们来看看open()，它用来打开文件。返回值3代表执行成功（3是内核成功打开文件后返回的文件描述符）。在它后面，你可以看到cat从/dev/null（read()中也包含文件描述符3）读取数据。在读取完所有数据后，程序关闭文件描述符，调用exit_group()退出。

如果过程中发生错误会出现什么情况？你可以使用strace cat not_a_file命令来检查open()的执行情况：

```
open("not_a_file", O_RDONLY|O_LARGEFILE) = -1 ENOENT (No such file or
directory)
```

上面显示open()无法打开文件，它返回-1代表出错。你可以看到，strace显示确切的错误代码和错误信息。

Unix上的程序经常会遇到无法找到文件的情况，如果系统日志和其他日志无法提供有帮助的信息时，你可以使用strace。strace甚至还可以用于那些已经和源进程分离的daemon程序，如：

$ **strace -o crummyd_strace -ff crummyd**

上面的-o选项为所有由crummyd产生的子进程记录日志，并保存到crummyd.strace.pid文件中，其中pid是子进程的PID。

###8.3.2 ltrace

ltrace命令跟踪对共享库的调用。它的输出结果和strace类似，所以我们在这里提一下，但是它不跟踪内核级的内容。请记住对共享库的调用比系统调用数量多得多。所以你有必要过滤ltrace命令的输出结果，ltrace命令有很多选项可以帮到你。

<center>注解</center>

*有关共享库的细节可参考`15.1.4 共享库`。ltrace命令对静态连接二进制库无效。*

##8.4 线程

在Linux中，一些进程被细分为更小的部分，我们称为线程（threads）。线程和进程很类似，它有一个标识符（线程ID或TID），内核运行线程的方式和进程相同。不同之处在于，进程之间不共享内存和I/O这样的系统资源，而同一个进程中的所有线程则共享该进程占用的系统资源。

###8.4.1 单线程进程和多线程进程

很多进程之有一个线程，叫单线程（single-threaded）进程，有超过一个线程的叫多线程（multithreaded）进程。所有进程最开始都是单线程，起始线程通常称为主线程（main thread）。主线程随后可能会启动新的线程，这样进程就变为多线程，这个过程和进程使用fork()创建新进程类似。

<center>注解</center>

*对于单线程的进程来我们很少提及线程。本书中除非是多线程进程，否则我们提及线程。*

多线程的主要优势在于，当进程要做的事情很多时，多个线程可以同时在多个处理器上运行，这样可以加快进程的运行速度。虽然你也可以同时在多个处理器上运行多个进程，线程相对进程来说启动更快，并且线程间通过共享的进程内存来相互通讯，比进程间通过网络和管道相互通讯效率更高。

一些应用程序使用线程来管理多个I/O资源。传统上来说，进程可以使用fork()来创建新的子进程来处理新的输入输出流。线程提供相似的机制，并且没有启动进程的成本。

###8.4.2 查看线程

默认情况下，ps和top命令只显示进程的信息。可以使用m选项来让它们显示线程的信息，如下例所示：

<i>例8-1. 使用ps m查看线程</i>

$ **ps** m

```
PID TTY STAT TIME COMMAND
3587 pts/3 - 0:00 bash➊
- - Ss 0:00 -
3592 pts/4 - 0:00 bash➋
- - Ss 0:00 -
12287 pts/8 - 0:54 /usr/bin/python /usr/bin/gm-notify➌
-- SL1 0:48 -
-- SL1 0:00 -
-- SL1 0:06 -
-- SL1 0:00 -
```

该例显示进程和线程的信息。每一行有一个PID列（在➊，➋，➌处），代表一个进程，和一般的ps输出一样。PID列为-的那些行代表进程中的线程。本例中进程➊和➋只有一个线程，进程➌（PID为12287）有四个线程。

如果想要使用ps查看线程ID，需要使用自定义的输出格式。下面的例子显示进程ID，线程ID，以及相关命令。

<i>例8-2. 使用ps m查看进程和线程ID</i>

$ **ps m -o pid,tid,command**

```
PID TID COMMAND
3587 - bash
- 3587 -
3592 - bash
- 3592 -
12287 - /usr/bin/python /usr/bin/gm-notify
- 12287 -
- 12288 -
- 12289 -
- 12295 -
```

`例8-2`中显示的线程和`例8-1`中的相对应。请注意单线程进程中的线程ID和进程ID相同，即主线程。对于多线程进程12287，线程12287是主线程。

<center>注解</center>

*和进程不同，通常你不会和线程进行交互。要和多线程应用中的线程打交道，你需要对该应用的具体实现非常了解，即使这样也不推荐这种方式。*

就资源监控而言，线程可能会带来一些困惑，因为在多线程进程中，多个线程可能同时访问资源。例如，top默认情况下不显示线程，你需要按H键来显示线程。我们马上将要介绍很多资源监控工具，它们需要一些额外的步骤来打开线程显示功能。

##8.5 资源监控简介

我们来介绍一下资源监控，包括处理器（CPU）时间，内存和磁盘I/O。我们将从系统和进程两个层面来了解。

很多人为了提高性能去深入了解Linux内核。然而，大部分Linux系统在缺省配置下性能都不错，可能浪费很多时间优化你也无法达到期望的效果，特别是在你对系统没有足够了解的时候更是如此。所以与其使用各种工具来尝试性能优化，不如来看看内核如何在进程之间分配资源。

##8.6 测量CPU时间

如果要监控进程，可以使用top命令加-p选项，如下：

$ **top -p pid1 [-p pid2 ...]**

使用time命令可以查看命令整个执行过程中占用的CPU时间。大部分shell提供的shell命令只显示一些基本信息，所以你可能需要运行/usr/bin/time。例如，如果要查看ls命令占用的CPU时间，可以运行：

$ **/usr/bin/time ls**

time在ls结束后会显示象下面这样的结果，关键的部分我们使用粗体字标出：

```
0.05user 0.09system 0:00.44elapsed 31%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (125major+51minor)pagefaults 0swaps
```

- 用户时间，CPU用来运行程序代码的时间，以秒为单位。在现在的处理器中，命令的运行速度很快，有些执行不超过一秒，time命令会将它们四舍五入为0.
- 系统时间，CPU用来执行进程任务的时间（例如读取文件和目录）。
- 消耗时间，进程从开始到结束所用的时间，包括CPU执行其他任务的时间。这个数字在检测性能方面不是很有帮助，不过将消耗时间减去用户时间和系统时间所剩余的时间，能够让你得知进程等待系统资源所消耗的时间。

剩下的有关内存和I/O使用的内容，我们将在`8.9 内存`一节中介绍。

##8.7 调整进程优先级

你可以调整内核对进程的安排，从而安排增加或减少安排给进程的CPU时间。内核按照它自己的优先级来运行进程，这些优先级用-20和20之间的数字表示，-20是最高的优先级。（有点晕是不是？）

ps -l命令显示当前进程的优先级，不过使用top命令更容易一点，如下所示：

$ **top**

```
Tasks: 244 total, 2 running, 242 sleeping, 0 stopped, 0 zombie
Cpu(s): 31.7%us, 2.8%sy, 0.0%ni, 65.4%id, 0.2%wa, 0.0%hi, 0.0%si, 0.0%st
Mem: 6137216k total, 5583560k used, 553656k free, 72008k buffers Swap: 4135932k total, 694192k used, 3441740k free, 767640k cached
PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
28883 bri 20 0 1280m 763m 32m S 58 12.7 213:00.65 chromium-browse
1175 root 20 0 210m 43m 28m R 44 0.7 14292:35 Xorg
4022 bri 20 0 413m 201m 28m S 29 3.4 3640:13 chromium-browse
4029 bri 20 0 378m 206m 19m S 2 3.5 32:50.86 chromium-browse
3971 bri 20 0 881m 359m 32m S 2 6.0 563:06.88 chromium-browse
5378 bri 20 0 152m 10m 7064 S 1 0.2 24:30.21 compiz
3821 bri 20 0 312m 37m 14m S 0 0.6 29:25.57 soffice.bin
4117 bri 20 0 321m 105m 18m S 0 1.8 34:55.01 chromium-browse
4138 bri 20 0 331m 99m 21m S 0 1.7 121:44.19 chromium-browse
4274 bri 20 0 232m 60m 13m S 0 1.0 37:33.78 chromium-browse
4267 bri 20 0 1102m 844m 11m S 0 14.1 29:59.27 chromium-browse
2327 bri 20 0 301m 43m 16m S 0 0.7 109:55.65 unity-2d-shell
```

上面的输出结果中，PR（priority）列显示内核当前赋予进程的优先级。这个数字越大，内核调用该进程的几率越小。决定内核分配给进程CPU时间的不仅仅是优先级，并且优先级在进程执行过程中也会根据其消耗的CPU时间经常改变。

优先级列旁边是nice value（NI）列，显示有关内核进程调度的一点信息，如果你想干预内核的进程调度，这个信息对你会有用。内核使用nice value来决定进程下一次在什么时间运行。

Nice value默认值是0。比如说你在后台运行一个计算量很大的进程，不希望影响到前台的交互。你希望在其他进程空闲的时候再运行该进程，就可以使用renice命令将nice value设置为20（pid是你要设置的进程的ID）：

$ **renice 20 pid**

如果你是超级用户，你可以将nice value设置为一个负数，不过这样系统级进程也许无法获得足够的CPU时间。因为Linux系统大多时候是单个用户在使用，所以没有太多竞争，你可能也不需要自己设置nice value。（从前多用户使用系统的时候，nice value就重要得多。）

##8.8 平均负载

CPU的性能比较容易来衡量。平均负载（Load average）是准备就绪可执行的进程的平均数。也就是某一时刻可以使用CPU的进程数一个估计值。系统中大多数进程通常把时间花在等待输入上（从键盘，鼠标，网络等），这意味着这些进程没有准备就绪可执行，所以并不计入平均负载。只有那些真正在运行的进程才计入平均负载。

###8.8.1 uptime的使用

Uptime命令显示三个平均负载值，还有内核已经运行的时长：

$ **uptime**

```
... up 91 days, ... load average: 0.08, 0.03, 0.01
```

以上三个粗体数字分别代表过去1分钟，5分钟和15分钟的平均负载值。如你所见，系统并不恨繁忙：过去15分钟只有平均数目为0.01的进程在运行。也就是说，如果你只有一个处理器，它过去15分钟只运行了用户空间应用的1%。（一般来说，大部分桌面系统的平均负载为1%，除非你在编译程序或者玩游戏。平均负载为0通常是一个好迹象，说明CPU不是很忙，系统很省电）

<center>注解</center>

*目前桌面系统的用户界面组件比以往使用更多的CPU。例如Linux，Web浏览器的Flash插件可能消耗很多资源，一些蹩脚的Flash应用动辄占用大量的CPU和内存。*

如果平均负载值达到1，说明某个进程可能完全占用了CPU。这是可以使用top命令来查看，通常就是出现在列表最上方的那个。

现在很多系统有多核（处理器），它们使得进程能够同时运行。如果你有两个核并且平均负载为1，这意味着只有其中一个处于活跃状态，如果平均负载为2，说明两个都处于忙状态。

###8.8.2 高负载

平均负载值高并不一定表示系统出现了问题。系统如果有足够的内存和I/O资源可以运行许多进程。如果平均负载值高的同时系统响应速度还很快，就不需要太担心，这说明系统中有很多进程在共享CPU。进城间需要相互竞争CPU时间，如果它们放任其他进程长时间占有CPU，它们自身的运行时间就会大大增长。对于Web服务器来说，高平均负载值也是正常现象，因为进程启动和结束得很快，以至于平均负载检测机制无法获得有效的数据。

然而，如果平均负载值高并且系统响应速度很慢的话，可能意味着内存性能问题。当系统出现内存不足的时候，内核会开始thrash，或者在磁盘和内存间交换（swap）进程数据。此时很多进程会处于执行准备就绪状态，但是可能没有足够内存，因而它们会保持这个状态（计入平均负载）比正常情况更久一些。

##8.9 内存

查看系统内存状态最简单的方法之一是使用free命令，或者查看/proc/meminfo文件来了解系统内存被作为缓存（cache）和缓冲区（buffer）的使用情况。我们前面介绍过，内存不足可能导致性能问题。如果没有足够内存用作缓存和缓冲区（被其他程序占用）的话，也许你需要考虑增加内存。不过人们总是拿内存不足来解释性能方面的问题。

###8.9.1 内存工作原理

我们在`第一章`介绍过CPU有一个内存管理单元（MMU）用来将进程使用的虚拟地址转换为实际的内存地址。内核帮助MMU把进程使用的内存划分为更小的区域，我们成为页面（pages）。内核负责维护一个数据结构，我们称为页面表（page table），其中包含从虚拟页面地址到实际内存地址的映射关系。当进程访问内存时，MMU根据此表将进程使用的虚拟地址转换为实际的内存地址。

进程执行时并不需要立即加载它所有的内存页面。内核通常在进程需要的时候加载和分配内存页面，我们称为按需内存分页（on-demand paging或者demand paging）。要了解它的工作原理，让我们来看一看进程是如何启动的运行的：

1. 内核将程序的指令代码的开始部分加载到内存页面内。
2. 内核可能还会为新进程分配一些内存页面供其运行使用。
3. 进程执行过程中，可能代码中的下一个指令在已加载的内存页面中不存在。这时内核接管控制，加载需要的内存页面，然后让程序恢复运行。
4. 同样地，如果进程需要使用更多的内存，内核接管控制，并且获得空闲的内存空间（或者腾出一些内存空间）分配给进程。

###8.9.2 内存页面错误

如果内存页面在进程想要使用时没有准备就绪，进程会产生内存页面错误（page fault）。错误产生时，内核从进程接管CPU的控制权，然后使内存页面准备就绪。内存页面错误有两种：轻微错误和严重错误。

####轻微内存页面错误

进程需要的内存页面在主内存中但是MMU无法找到时，会产生轻微内存页面错误。通常时进程需要更多内存，然而MMU没有内存空间来存放所有的页面。这时内核会通知MMU并且让进程继续执行。轻微内存页面错误不是很严重，在进程执行过程中可能会出现。通常你不需要对此太在意，除非是那些对性能和内存要求很高的应用。

####严重内存页面错误

严重内存页面错误发生在进程需要的内存页面在主内存中不存在时，意味着内核需要从磁盘或者其他存储媒介中加载。太多此类错误会影响系统性能，因为内核必须做大量的工作来为进程加载内存页面，占用大量CPU时间，妨碍其他进程的运行。

####查看内存页面错误

你可以使用ps，top和time命令为某个进程的内存页面错误查找原因。下面是一个例子，说明time命令提供的内存页面错误信息。（cal命令的输出可以忽略，我们将其重定向到/dev/null）

$ **/usr/bin/time cal > /dev/null**

```
0.00user 0.00system 0:00.06elapsed 0%CPU (0avgtext+0avgdata
3328maxresident)k
648inputs+0outputs (2major+254minor)pagefaults 0swaps
```

从以上加粗的信息可以看出，程序运行过程中产生了2个严重内存页面错误和254个轻微内存页面错误。严重内存页面错误发生在当内核最开始从磁盘加载程序的时候。如果再次运行该程序，你可能不会再碰到严重内存页面错误，因为内核可能已经将从磁盘加载的内存页面放入缓存了。

如果你想在进程运行过程中查看产生的内存页面错误，可以使用top或者ps命令。可以使用top命令加f选项设置显示的列，u选项显示严重内存页面错误的数目。（结果会显示在一个新的列,nFLT中，轻微内存页面错误不显示）

使用ps命令时，你可以使用自定义输出格式来查看某个进程产生的内存页面错误。下面是进程20365的一个例子：

$ **ps -o pid,min_flt,maj_flt 20365 **

```
PID     MINFL   MAJFL
20365   834182  23
```

MINFL和MAJFL列显示轻微和严重内存页面错误数目。在此基础上你还可以加入其他的进程选择参数，请参见帮助手册ps(1)。

查看内存也看错误能够帮助你定位出现问题的组建。如果你对整个系统的性能感兴趣，你需要汇总所有进程的CPU和内存相关信息。

###8.10 使用vmstat监控CPU和内存性能

在众多系统性能监控工具中，vmstat命令是最陈旧的一个之一，但运行开销也最小。你可以使用它来了解内核交换内存页面的频率，CPU的繁忙程度，以及IO的使用情况。

通过查看vmstat的输出结果能够获得很多有用的信息。下面是vmstat 2命令的输出结果，其每2秒刷新一次统计信息：

$ **vmstat 2**

```
procs -----------memory---------- ---swap-- -----io---- -system-- ---- cpu----
r b swpd free buff cache si so bi bo in cs us sy id wa
2 0 320416 3027696 198636 1072568 0 0 1 1 2 0 15 2 83 0
2 0 320416 3027288 198636 1072564 0 0 0 1182 407 636 1 0 99 0
1 0 320416 3026792 198640 1072572 0 0 0 58 281 537 1 0 99 0
0 0 320416 3024932 198648 1074924 0 0 0 308 318 541 0 0 99 1
0 0 320416 3024932 198648 1074968 0 0 0 0 208 416 0 0 99 0
0 0 320416 3026800 198648 1072616 0 0 0 0 207 389 0 0 100 0
```

输出结果可以归为这几类：procs（进程），memory（内存使用），swap（内存页面交换），io（磁盘使用），system（内核切换到内核代码的次数），cpu（系统各组件使用CPU的时间）。

上例中的系统负载并不大。通常我们从第二行看起，第一行是系统整个运行时期的平均值。例如上例中，系统有320416KB内存被交换到磁盘（swpd），有大约3025000KB（3GB）空闲内存。虽然有一部分交换空间正在被占用，但是si（换入，swap-in）和so（换出，swåap-out）列仍显示内核没有在交换内存。Buff列显示内核用于磁盘缓冲区的内存（可参考`4.2.5 磁盘缓冲，缓存，和文件系统`）。

在最右边的CPU列，你可以看到CPU时间被分为us，sy，id和wa列。它们依次代表用户任务，系统（内核）任务，空闲时间和I/O等待时间等占用的CPU时间的百分比。上例中运行的用户进程不多（只占用了最多1%的CPU时间），而内核基本上是空闲的，CPU在99%的时间内均为空闲。

现在让我们来看看一个庞大的程序启动后会发生什么情况（前两行显示的是命令运行后的状态）：

<i>例8-3. 内存活动</i>

```
procs -----------memory---------- ---swap-- -----io---- -system-- ---- cpu----
r b swpd free buff cache si so bi bo in cs us sy id wa
1 0 320412 2861252 198920 1106804 0 0 0 0 2477 4481 25 2 72 0➊
1 0 320412 2861748 198924 1105624 0 0 0 40 2206 3966 26 2 72 0
1 0 320412 2860508 199320 1106504 0 0 210 18 2201 3904 26 2 71 1
1 1 320412 2817860 199332 1146052 0 0 19912 0 2446 4223 26 3 63 8
2 2 320284 2791608 200612 1157752 202 0 4960 854 3371 5714 27 3 51 18➋
1 1 320252 2772076 201076 1166656 10 0 2142 1190 4188 7537 30 3 53 14
0 3 320244 2727632 202104 1175420 20 0 1890 216 4631 8706 36 4 46 14
```

`例8-3`中的➊显示，CPU在一段时间内开始出现一定的使用量，特别是针对用户进程。因为可用内存充足，在内核越来越多使用磁盘的时候，缓存和缓冲的使用量开始增大，

随后我们看到一个有趣的现象：➋显示内核将一些被交换出（si列）磁盘的内存页面加载到内存中。这表示刚刚运行的程序有可能使用了一些和其他进程共享的内存页面。这种情况很常见，很多进程在启动时会使用到一些共享库代码。

请注意在b列中有一些进程在等待内存页面时状态为blocked（阻塞无法运行）。简单说就是可用内存在减少，但是还未耗尽。上例中还有一些磁盘相关的进程，从bi（blocks in）和bo（blocks out）列不断增大的数字可以看出。

在内存耗尽的时候，输出结果则大为不同。内存耗尽时，因为内核需要为用户进程分配内存，缓冲区和缓存空间开始减少。一旦内存耗尽，内核开始将内存页面交换到磁盘，在so（swap out）列中会开始出现进程，此时其他列的信息会相应变更。系统时间值会变大，数据交换更频繁，更多的进程处于阻塞状态，因为它们所需的内存不可用（已经被交换出磁盘）。

我们还未介绍完vmstat的所有列。你可以使用vmstat(8)查看帮助手册获得更详细的文档，不过推荐先从《Operating System Concepts》， 9th Edition（Wiley，2012）这类书，或者其他渠道学习内核内存管理方面的知识。

##8.11 I/O监控

vmstat显示常用的I/O统计信息。你可以使用vmstat -d获得各列详细的资源使用情况，有时信息过多也让人抓狂。我们可以从专门针对I/O的命令iostat看起。

###8.11.1 使用iostat

和vmstat类似，iostat在不带任何参数时显示系统的当前uptime信息：

$ **iostat**

```
[kernel information]
avg-cpu: %user %nice %system %iowait %steal %idle
 4.46 0.01 0.67 0.31 0.00 94.55
 
Device: tp s kB_read/s kB_wrtn/s kB_read kB_wrtn
sda 4.6 7 7.2 8 49.86 9493727 65011716
sde 0.0 0 0.0 0 0.00 1230 0
```

上面avg-cpu部分和本章介绍的其他工具一样，显示的是CPU的使用信息，往下是各个设备的情况，如下所示：

<table>
<tbody>
<tr> <td>**tps** </td> <td> Average number of data transfers per second</td></tr>
<tr>￼ <td>**kB_read/s** </td> <td> Average number of kilobytes read per second </td></tr>
<tr>￼ <td>**kB_wrtn/s** </td> <td> Average number of kilobytes written per second </td></tr>
<tr>￼ <td>**kB_read** </td><td> Total number of kilobytes read </td> </tr>
<tr>￼ <td>**kB_wrtn** </td><td> Total number of kilobytes written </td></tr>
</tbody>
</table>

iostat和vmstat的另一个相似之处是你可以设定一个间隔选项，如：iostat 2，这样可以每隔2秒更新一次信息。间隔参数可以和-d选项配合使用（如：iostat -d 2）。

默认情况下，iostat的输出结果不包含分区信息。可以使用-p ALL选项来显示分区信息。因为系统上的分区数量可能会很多，所以输出的信息量也会很大。下面是部分输出示例：

$ **iostat -p ALL --snip**

```
--snip
--Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn
--snip-
sda 4.67 7.27 49.83 9496139 65051472
sda1 4.38 7.16 49.51 9352969 64635440
sda2 0.00 0.00 0.00 6 0
sda5 0.01 0.11 0.32 141884 416032
scd0 0.00 0.00 0.00 0 0
--snip--
sde 0.00 0.00 0.00 1230 0
```

上例中，sda1，sda2和sda5均为sda磁盘上的分区，因而读和写两列的信息可能会有重叠。然而各分区的总和并不一定等于磁盘的总容量。sda1的读同时也是sda的读，请注意从sda直接读取数据是可能的，比如读取分区表数据。

###8.11.2 使用iotop查看进程的I/O使用和监控

如果想要更深入地了解各个进程对I/O资源的使用情况，可以使用iotop工具。使用方法和top一样。它会持续显示使用I/O最多的进程，最顶端是汇总数据：

\# **iotop**

```
Total DISK READ: 4.76 K/s | Total DISK WRITE: 333.31 K/s
TID PRIO USER DISK READ DISK WRITE SWAPIN IO> COMMAND
260 be/3 root 0.00 B/s 38.09 K/s 0.00 % 6.98 % [jbd2/sda1-8]
2611 be/4 juser 4.76 K/s 10.32 K/s 0.00 % 0.21 % zeitgeist-daemon
2636 be/4 juser 0.00 B/s 84.12 K/s 0.00 % 0.20 % zeitgeist-fts
1329 be/4 juser 0.00 B/s 65.87 K/s 0.00 % 0.03 % soffice.b~ash-pipe=6
￼ 6845 be/4 juser 0.00 B/s 812.63 B/s 0.00 % 0.00 % chromium-browser
19069 be/4 juser 0.00 B/s 812.63 B/s 0.00 % 0.00 % rhythmbox
```

请注意除了user，command，read/write列之外，还有一列叫TID（线程ID，thread ID），而非进程ID。iotop是为数不多的显示线程而非进程的工具。

PRIO（priority）列表示I/O的优先级。它类似于我们介绍过的CPU优先级，它决定了内核为进程执行I/O读写操作分配多长时间。如果优先级为be/4，be代表scheduling class，数字则代表优先级别。和CPU优先级一样，数字越小优先级越高。比如内核会为be/3的进程分配比be/4的进程更多的时间。

内核使用日程安排类（scheduling class）为I/O日程安排加入更多控制。iotop中有三种scheduling class：

- **be** Best-effort。内核尽其所能为其公平地安排I/O时间。大部分进程在归为此类。
- **rt** Real-time。内核优先安排real-time类I/O。
- **idel** 空闲类。内核只在没有其他I/O工作的时候安排此类I/O工作。此类工作不具备优先级。

你可以使用ionice工具来查看和更改进程的I/O优先级，详情请参考ionice(1)帮助手册。一般情况下你不用关心I/O优先级。

##8.12 使用pidstat监控进程

我们已经介绍过如何使用top和iotop来监控进程。它们都会不断刷新输出结果，旧的输出被新的覆盖。工具pidstat能够让你使用vmstat的方式来查看进程的资源使用情况。下面是进程1329的例子，每秒刷新一次：

$ **pidstat -p 1329 1**

```
Linux 3.2.0-44-generic-pae (duplex) 07/01/2015 _i686_ (4 CPU)
09:26:55 PM PID %usr %system %guest %CPU CPU Command
09:27:03 PM 1329 8.00 0.00 0.00 8.00 1 myprocess
09:27:04 PM 1329 0.00 0.00 0.00 0.00 3 myprocess
09:27:05 PM 1329 3.00 0.00 0.00 3.00 1 myprocess
09:27:06 PM 1329 8.00 0.00 0.00 8.00 3 myprocess
09:27:07 PM 1329 2.00 0.00 0.00 2.00 3 myprocess 
09:27:08 PM 1329 6.00 0.00 0.00 6.00 2 myprocess
```

该命令在默认情况下显示用户时间和系统时间的百分比，以及综合的CPU时间百分比，还显示进程在哪一个CPU上运行。（列%guest有一点奇怪，是进程运行在虚拟机上的时间的百分比，除非你运行在虚拟机上，否则可以忽略它）

虽然pidstat缺省显示CPU的使用情况，它还有其他很多功能。例如我们可以使用-r选项来监控内存，-d选项来监控磁盘。你可以自己尝试运行一下，更多针对线程，上下文切换和其他本章介绍的方面的选项可以参考pidstat(1)帮助手册。

##8.13 更深入的主题

针对资源监控有很多的工具，其中一个原因是资源的种类很多，不同资源的使用方式不同。本章我们介绍了进程如何使用CPU,内存，和I/O等系统资源，以及进程中的线程和内核。

另外一个原因是系统的资源是有限的，考虑到性能，系统中的各个组件都需要尽可能地少消耗资源。过去很多用户共享一台计算机，所以需要保证每个用户公平地获得资源。现在的桌面系统都是单人使用，但是其中的进程仍然相互竞争以获取资源。并且高性能的网络服务器对系统资源监控的要求更高。

更深入的有关资源监控和性能分析的主题有：

- **sar（系统活动报告，System Activity Reporter）** sar包含很多vmstat的持续监控功能，另外还记录系统资源一直以来的使用情况。sar让你能够查看过去某一时刻的系统状态，这在你需要查看已发生的系统事件时非常有用。
- **acct（Process accounting）** acct能够记录进程以及它们使用资源的情况。
- **Quotas**，你可以将某些系统资源限制给某个进程和用户使用。可以到/etc/security/limits.conf中查看一些CPU和内存选项，帮助手册中也有limits.conf(5)文档。这是PAM的一个特性，只适用于哪些通过PAM启动的进程（如login shell）。你还可以使用quota来限制用户可以使用的磁盘空间。

如果你对系统性能调优感兴趣，《Systems Performance: Enterprise and the Cloud》，作者Brendan Gregg（Prentice Hall，2013）一书中有详细的介绍。

关于网络监控和资源使用，我们还有很多工具未介绍。在使用这些工具之前，你需要先了解网络的工作原理，我们将在下章介绍。
