#第五章 Linux内核的启动
![图像说明文字](/api/storage/getbykey/inlineimage?key=1502f3b8964ebd2ff2cf)

目前为止我们介绍了Linux系统的物理结构和逻辑结构，内核，以及进程。本章我们将讨论内核的启动（boot）。即从内核载入内存到启动第一个用户进程的过程。

下面是简化后的整个过程：

1. BIOS（基本输入输出系统）或者启动固件加载并运行引导装载程序（boot loader）。
2. 引导装载程序在磁盘上找到内核映像，将其载入内存并启动。
3. 内核初始化设备及其驱动程序。
4. 内核挂载根文件系统。
5. 内核使用进程ID 1来运行init程序，用户空间在此时开始启动。
6. init启动其他的系统进程。
7. init还会启动一个进程，通常在整个过程的尾声，负责用户登录。

本章涉及前4个步骤，主要介绍内核和引导装载程序。在**第六章**我们会介绍用户空间启动。

理解启动过程对将来修复启动相关的问题会大有帮助，也有助于了解整个Linux系统。然而，你很难从Linux系统的默认启动过程中分辨出最前面的几个步骤，通常只有在整个过程完成，你登录系统后才有机会看到。

##5.1 启动消息

传统的Unix系统在启动时会显示很多系统信息，方便你查看启动过程。这些消息一开始来自内核，然后是进程和init执行的初始化程序。然而，这些消息格式不是那么清晰和一致，有时甚至不是那么有用。现在大部分Linux版本都使用启动屏幕、屏幕填充色，和启动选项菜单将它们遮盖住。此外，硬件性能的提升也让启动过程更快，这些消息显示得也更快，快到让人难以捕捉。

有两种方法可以查看内核启动信息和运行时的诊断信息：

- 查看内核系统日志文件。通常存放在/var/log/kern.log中，取决于你的系统配置，也可能和其他系统日志一起存放在/var/log/messages或者别的什么地方。
- 使用dmesg命令，不过记得将结果输出到less，因为信息量会比较大。dmesg命令使用内核环缓冲区，它的容量有限，不过大多数较新的内核能够有足够的空间来容纳足够长的启动日志。

以下是一个dmesg的示例：

$ **dmesg**

[ 0.000000] Initializing cgroup subsys cpu

[ 0.000000] Linux version 3.2.0-67-generic-pae (buildd@toyol) (gcc version 4.
6.3 (Ubuntu/Linaro 4.6.3-1ubuntu5) ) #101-Ubuntu SMP Tue Jul 15 18:04:54 UTC 2014
(Ubuntu 3.2.0-67.101-generic-pae 3.2.60)

[ 0.000000] KERNEL supported cpus:

--snip--

[ 2.986148] sr0: scsi3-mmc drive: 24x/8x writer dvd-ram cd/rw xa/form2
cdda tray

[ 2.986153] cdrom: Uniform CD-ROM driver Revision: 3.20

[ 2.986316] sr 1:0:0:0: Attached scsi CD-ROM sr0

[ 2.986416] sr 1:0:0:0: Attached scsi generic sg1 type 5

[ 3.007862] sda: sda1 sda2 < sda5 >

[ 3.008658] sd 0:0:0:0: [sda] Attached SCSI disk 

--snip--

内核启动后，用户空间启动程序会产生消息。查看这些消息不是很方便，因为它们分布在很多不同的地方。启动脚本通常会将消息显示到屏幕上，启动完成后就从屏幕上消失了。因为每个脚本都将消息写入它们各自的日志，所以不存在前面的问题。有一些版本的init，比如Upstart和systemd，可以获得那些显示到屏幕的启动和运行时消息。

##5.2 内核初始化和启动选项

Linux内核的启动过程如下：

1. 检查CPU
2. 检查内存
3. 检测设备总线
4. 检测设备
5. 设置附加内核子系统（如：网络等）
6. 挂载根目录
7. 启动用户空间

前面几个步骤很好理解，设备相关的步骤则涉及一些依赖性问题。例如：磁盘设备驱动程序可能需要依赖于总线和SCSI子系统的支持。

在后面的几个步骤中，内核必须在初始化前挂载根文件系统。你可以忽略大部分细节，除了一点，就是一些组件并不是主内核的一部分，它们会以可加载内核模块的方式启动。在一些系统中，你可能需要在挂载根文件系统之前加载这些内核模块。详细内容我们将在**6.8 RAM文件系统初始化**一节介绍。

直到本书写成时，内核在启动第一个用户进程时不会显示任何消息。然而下面的这些内存管理相关消息能够为我们提供一些信息，如下所示，内核将自己的内存空间保护起来以防止用户空间进程使用，下面这些信息预示着用户空间即将启动：

Freeing unused kernel memory: 740k freed

Write protecting the kernel text: 5820k

Write protecting the kernel read-only data: 2376k

NX-protecting the kernel data: 4420k

这时你还可以看到根文件系统的挂载信息。

**注解**
*本章下面的内容涉及内核启动的细节，你可以跳到第六章学习用户空间启动，以及内核初始化第一个用户进程等内容。*

##5.3 内核参数

运行Linux内核的时候，引导装载程序会向内核传递一系列文本形式的内核参数来设定内核的启动方式。这些参数设定了很多不同的行为方式，比如内核显示的诊断信息的多少，和设备驱动程序相关参数。

你可以通过/proc/cmdline文件来查看系统启动时使用的内核参数：

$ **cat /proc/cmdline**

BOOT_IMAGE=/boot/vmlinuz-3.2.0-67-generic-pae root=UUID=70ccd6e7-6ae6-
44f6-

  812c-51aab8036d29 ro quiet splash vt.handoff=7

这些参数有的是一个单词的长度，诸如：ro，quiet，有的是key=value这样的配对（例如：vt.handoff=7）。它们中大部分都无关紧要，如：splash标志意思是显示一个闪屏（splash screen）。其中root参数很重要，它是根文件系统存放的位置，如果没有这个参数，内核将无法完成初始化工作，从而也就无法启动用户空间。

根文件系统参数值是一个设备文件，例如：

root=/dev/sda1

然而现在的桌面系统中经常使用UUID（见**4.2.4 文件系统UUID**）：

root=UUID=70ccd6e7-6ae6-44f6-812c-51aab8036d29

参数ro告诉内核在用户空间启动时以只读模式挂载根文件系统。（使用只读模式能够让fsck安全地对根文件系统做检查，之后启动进程重新以可读写模式来挂载根文件系统。）

如果遇到无法识别的参数，Linux内核会将其保存，稍后在启动用户空间时传递给init。如果你加入参数-s，内核会将其传递给init，让其以单用户模式启动。

下面我们介绍引导装载程序是如何启动内核的。

##5.4 引导装载程序

在启动过程的最开始，引导装载程序启动内核，然后内核和init启动。引导装载程序的工作看似很简单：将内核加载到内存，然后使用一系列内核参数启动内核。但是引导装载程序需要弄清楚下面几个问题：

- 内核在哪里？
- 内核启动时需要传递哪些参数？

内核及其参数通常在根文件系统中。因为内核此时还没有开始运行，无法遍历文件系统，所以内核参数需要被放到一个容易存取的地方。并且此时用于访问磁盘的内核设备驱动还没有准备好，这听起来有点像“鸡生蛋，蛋生鸡”。

我们先看一下驱动程序。在个人电脑上，引导装载程序使用基本输入输出（BIOS）或者统一可扩展固件接口（Unified
Extensible Firmware Interface，UEFI）来访问磁盘。几乎所有的磁盘设备都有固件系统供BIOS通过线性块寻址来访问硬件（Linear Block Addressing，LBA）。虽然性能不怎么样，但是这种方式可以访问磁盘的任意位置。引导装载程序往往是唯一使用BIOS访问磁盘的程序，内核使用的是它自己的高性能驱动程序。

大多数现在的引导装载程序都能够读取分区表，内建以只读模式访问文件系统的功能，因此它们能够查找和读取文件。这使得动态配置和完善引导装载程序变得非常简单。并不是所有的Linux引导装载程序都有这些功能，配置引导装载程序因而变的困难得多。

###5.4.1 引导装载程序任务

Linux引导装载程序的核心功能如下：

- 从多个内核中选择一个使用。
- 从多个内核参数集中选择一个使用。
- 允许用户手工更改内核映像名和参数（例如使用单用户模式）。
- 支持其他操作系统的启动。

自Linux内核问世以来，引导装载程序的功能得到了极大的增强，加入了历史纪录和菜单界面，不过最基本的需求仍然是能够灵活选择内核映像和参数。有趣的是某些方面的需求逐渐消失了。例如，现在你可以从USB设备上执行紧急启动和恢复，因而你可能不再需要手工设置内核参数和进入单用户模式。不过因为现在引导装载程序强大的功能，更改内核参数、创建定制内核这些事情也变得容易得多。

###5.4.2 引导装载程序概述

以下是一些常见的引导装载程序，按照普及的顺序排列：

- GRUB，近乎于Linux系统标准。
- LILO，最早期的Linux引导装载程序之一，是UEFI的一个版本。
- SYSLINUX，能够在很多不同的文件系统上配置和启动。
- LOADIN，能够从MS-DOS上启动内核。
- efilinux，UEFI引导装载程序的一种，作为其他UEFI引导装载程序的模块和引用。
- coreboot（以前又叫做LinuxBIOS）PC BIOS的高性能替代品，并且能够包含内核。
- Linux Kernel EFISTUB，能够从EFI/UEFI系统分区（ESP）加载内核的一个内核插件。

本书只涉及GRUB，使用其他引导装载程序的原因在于它们更容易配置、更快速。

要设置内核名称和参数，你需要进入启动提示符（boot prompt）。因为很多Linux系统定制了引导装载程序，使得我们有时很难找到进入启动提示符的方法。
下一节我们会介绍如何进入启动提示符来设置内核名称和参数，然后你将了解如何设置和安装引导装载程序。

##5.5 GRUB简介

GRUB意指大一统引导装载程序（Grand Unified Boot Loader）。本节我们将介绍GRUB 2。GRUB有一个较老的版本叫做GRUB Legacy，现在逐步被淘汰了。

GRUB最重要的一个功能是对内核印象和配置的选择更为简便。我们可以通过查看菜单来了解GRUB。GRUB界面易于操作，不过Linux各版本都尽可能将引导装载程序隐藏起来，你可能没机会看到。

你可以在BIOS或者固件启动屏幕出现时按住SHIFT来打开GRUB菜单。图5-1中是GRUB菜单，可以按ESC来取消自动启动计时。

![图像说明文字](/api/storage/getbykey/screenshow?key=1502bf100060c916c757)
<center>图5-1. GRUB菜单</center>

可以通过以下步骤来查看引导装载程序：

1. 打开或者重启Linux。
2. 在BIOS/固件自检时或者启动屏幕显示时，按住SHIFT显示GRUB菜单。
3. 按e键查看引导装载程序命令的缺省启动选项，如**图5-2**所示：

![图像说明文字](/api/storage/getbykey/screenshow?key=1502cdfcb0a2ceea4f0e)
<center>图5-2. GRUB配置编辑器</center>

如图所示，根文件系统被设置为一个UUID，内核映像是/boot/vmlinuz- 3.2.0-31-generic-pae，内核参数包括ro，quiet和splash。初始RAM文件系统是/boot/initrd.img-3.2.0-31-generic-pae。如果你从来没有见过这些配置信息，可能会觉得比较糊涂。你可能会问为什么会有这么多地方涉及root？它们有什么区别？为什么这里会出现insmod？Linux内核不是通常由udevd运行吗？

我一说你就明白了，因为GRUB仅仅是启动内核，而不使用它，你看到的这些配置信息都由GRUB的内部命令构成，GRUB自身另成一个体系。

产生混淆的原因是由于GRUB借用了很多其他地方的术语。GRUB有自己的“内核”和insmod命令来动态加载GRUB模块，这和Linux内核没有任何关系。很多GRUB命令和Unix shell命令很类似，GRUB也有一个ls命令来显示文件列表。

不过最让人糊涂的地方还是root这个词。为了表达得更清楚，只需要遵循一个简单的法则就是：只有root内核参数是指根文件系统。

在GRUB配置中，root这个内核参数在linux命令中的映像文件名后面。其他配置信息中出现root的地方指的都是GRUB root，其只针对GRUB，是GRUB查找内核和RAM文件系统映像时使用的文件系统。

在**图5-2**中，GRUB root一开始被设置为GRUB相关设备（hd0, msdos1）。在随后的命令中，GRUB查找一个特定分区的UUID，如果找到的话就将该分区设置为GRUB root。

总而言之，linux命令的第一个参数（/boot/vmlinuz-...）是Linux内核映像文件的位置。GRUB从GRUB root上加载此文件。类似的，initrd命令指定初始的RAM文件系统文件。

你可以在GRUB内配置这些信息，通常启动错误可以用这种方式来暂时性地修复。如果要永久性地修复启动问题，你需要更改配置信息（见**5.5.2 GRUB配置**），不过目前让我们先深入GRUB内部，看看其命令行界面。

###5.5.1 使用GRUB命令行浏览设备和分区

如**图5-2**所示，GRUB有自己的设备寻址方式。例如，系统检测到的第一个硬盘是hd0，然后是hd1，以此类推。然而设备分配会有变化。还好GRUB能够在所有的分区中通过UUID来查找得内核所在的分区，就像你刚才在search命令看到的那样。

####设备列表

想要了解GRUB如何显示系统中的设备，可以在启动菜单活着配置编辑器中按C键进入GRUB命令行。你将看到以下提示符：

grub>

这里你可以运行任何你在配置信息中看到的命令，我们可以从ls命令开始，不带参数，命令的输出时GRUB能够识别的所有设备的列表：

grub> **ls**

(hd0) (hd0,msdos1) (hd0,msdos5)

本例中有一个名为hd0的主磁盘设备和分区（hd0, msdos1）及（hd0, msdos5）。前缀msdos表示磁盘包含MBR分区表。如果包含的是GPT分区表则前缀就是gpt。（还可能会有第三个标识符来表示更多可能的组合，如分区包含BSD磁盘标签映射，不过你通常不需要太关注，除非你在一台机器上运行多个操作系统）

使用ls -l查看更详细的信息。此命令能显示磁盘上所有分区的UUID，所以非常有用，例如：

grub> **ls -l**
![图像说明文字](/api/storage/getbykey/screenshow?key=15026a7f6fbc9edafba0)

如上所示，磁盘在第一个MBR分区上有一个Linux ext2/3/4文件系统，在分区5上有一个Linux交换区签名，这样的配置很常见。（从输出中可以看到hd0, msdos5是交换分区）

####文件导航

现在我们来看看GRUB的文件系统导航。你可以使用echo命令来查看GRUB根文件系统（这是GRUB寻找内核的地方）：

grub> **echo $root**

hd0,msdos1

可以在GRUB的ls命令中的分区后面加上/来显示根文件系统下文件和目录：

grub> **ls (hd0,msdos1)/**

不过要记住的键入分区名是件麻烦事，这时你可以使用root变量：

grub> **ls ($root)/**

输出结果是该分区上的文件系统中的目录和文件名列表，诸如：etc/，bin/，和dev/。你需要了解这个命令和GRUB ls的功能完全不同，后者列出设备、分区表盒文件系统头信息。而这个命令显示的是文件系统的内容。

使用类似的方法，你可以进一步查看分区上文件和目录的内容。例如，如果要查看boot目录的内容，可以使用：

grub> **ls ($root)/boot**

**注解**
*你可以使用上下键来查看命令历史记录，使用左右键来编辑当前命令行。也可以使用标准行命令如：CTRL-N, CTRL-P等。*

你也可以使用set命令查看所有已经设置的GRUB变量：

grub> **set**

?=0 

color_highlight=black/white 

color_normal=white/black 

--snip--

prefix=(hd0,msdos1)/boot/grub

root=hd0,msdos1

这些变量当中，$prefix是很重要的一个，GRUB使用它指定的文件系统和目录来寻找配置和辅助支持信息。我们将在下一节详细介绍。

使用GRUB命令行界面完成工作后，你可以键入boot命令来启动系统，或者按ESC键回到GRUB菜单来启动系统。整个系统启动完毕准备就绪之后，让我们我们来看看GRUB配置信息。

###5.5.2 GRUB配置信息

GRUB配置目录包含核心配置文件（grub.cfg）和一些列可加载模块，以.mod为后缀。（随着GRUB版本的演进，这些模块被逐渐移到象i386-pc这样的子目录中）。配置目录通常是/boot/grub或者/boot/grub2。我们不直接编辑grub.cfg文件，而是使用grub-mkconfig命令（或者Fedora上的grub2-mkconfig）。

####回顾grub.cfg

首先我们看一下GRUB是如何通过grub.cfg文件来初始化菜单和内核选项的。你会看到grub.cfg文件中包含GRUB命令，通常是从一些列的初始化步骤开始，然后是一系列的菜单条目，针对不同的内核和启动配置。初始化过程并不复杂，它就是一系列的函数定义和视频设置命令，如下所示：

if loadfont /usr/share/grub/unicode.pf2 ; then

  set gfxmode=auto

load_video insmod gfxterm 

--snip--

稍后在文件中你还会看到启动配置信息，它们以menuentry命令开始。通过上节的介绍，你应该能够理解以下这些内容：

menuentry 'Ubuntu, with Linux 3.2.0-34-generic-pae' --class ubuntu 

-- class gnu-linux --class gnu

--class os {

recordfail

gfxmode $linux_gfx_mode

insmod gzio

insmod part_msdos

insmod ext2

set root='(hd0,msdos1)'

search --no-floppy --fs-uuid --set=root 70ccd6e7-6ae6-44f6-812c- 
51aab8036d29

linux /boot/vmlinuz-3.2.0-34-generic-pae root=UUID=70ccd6e7-
6ae6-44f6-812c-51aab8036d29

ro quiet splash $vt_handoff

}

请留意submenu命令。如果你的grub.cfg文件包含一系列menuentry命令，它们中大多数可能被包含在submenu命令中，这是针对较老版本的内核设计的，以免GRUB菜单过于臃肿。

####生成新的配置文件

如果想要对GRUB配置做更改，我们不会直接编辑grub.cfg文件，因为它是由系统自动生成和更新的。你可以将新的配置信息放到其他什么地方，然后运行grub-mkconfig来生成新的配置文件。

在grub.cfg文件的最开头应该有一行注释，如下：

\#\#\# BEGIN /etc/grub.d/00_header \#\#\#

你会发现/etc/grub.d中的文件都是shell脚本，它们各自生成grub.cfg文件的某个部分。grub-mkconfig命令本身也是一个脚本文件，负责运行/etc/grub.d中的所有脚本文件。

你可以使用root账号来自己试一试。（不用担心当前的配置信息会被覆盖，该命令只会将配置信息输出到标准输出，即屏幕）

\# **grub-mkconfig**

如果你想要在GRUB配置中加入新的菜单条目和其他命令，简单来说，你可以在GRUB配置目录中创建一个新的.cfg文件来存放你的内容,例如：/boot/grub/custom.cfg。

如果涉及到细节就会复杂一些了。/etc/grub.d配置目录为你提供了两个选项：40_custom和41_custom。前者是一个脚本文件，你可以编辑，但是系统升级有可能会将你的更改清除掉，所以这个选项不太保险。41_custom脚本更简单一些，它是一组的命令，用来在GRUB启动的时候加载custom.cfg文件。（请注意，如果使用该方法，你的配置更改只有在配置文件生成后才会其作用。）

它们并不是唯一定制配置的方法。在一些Linux版本中，你有可能在/etc/grub.d目录中看到其他的选项。例如：Ubuntu在配置中加入了内存测试启动选项memtest86+。

你可以使用grub-mkconfig命令加-o选项将新生成的文件写到GRUB目录，如下所示：

\# **grub-mkconfig -o /boot/grub/grub.cfg**

如果你使用的是Ubuntu，可以使用install-grub。在进行这类操作的时候，请注意将旧的配置文件进行备份，以及确保目录路径正确。

现在让我们看看更多关于GRUB和引导装载程序的技术细节，如果你觉得已经了解得足够多，可以直接跳到**第六章**。

###5.5.3 安装GRUB

通常你不用太关注GRUB的安装，Linux系统会自行完成。不过如果你想复制和恢复可启动磁盘，或者自定义启动顺序，可能就需要自己安装GRUB。

在继续之前，你可以先阅读**5.8.3 GRUB工作原理**来了解系统如何启动，如何在MBR和EFI做选择。接着，你将编译GRUB可执行代码集，并且决定GRUB目录的位置（默认是/boot/grub）。如果Linux系统已经提供了GRUB软件包，你就不必自己动手，否则可以参考**第十六章**来学习如何从源码编译可执行代码。你需要确保目标（target）正确无误。这和MBR以及UEFI启动不同（32位EFI和64位EFI也不同）。

####在系统上安装GRUB

安装引导装载程序需要你或者安装程序决定以下几方面：

- 目标GRUB目录。通常是/boot/grub，不过如果你在不同的系统和磁盘上安装的话，目录位置可能会不一样。
- GRUB目标磁盘对应的设备。
- UEFI启动分区的挂载点，如果是UEFI启动的话。

请注意GRUB是一个模块化系统，它需要能够读取GRUB目录所在的文件系统来加载模块。你的任务就是构建一个GRUB系统，它能够读取文件系统，加配置文件（grub.cfg），以及其他需要的模块。在Linux上，这通常指的是使用预加载的ext2.mod模块来编译一个GRUB系统。编译完成后，你需要将其放到磁盘上的可启动区域，将其他需要用到的文件放到/book/grub目录中。

所幸的是，GRUB自带一个叫做grub-install的工具（不要和Ubuntu的install-grub混淆喔），它负责大部分的GRUB文件安装和配置工作。例如，如果你想在/dev/sda上安装GRUB目录/boot/grub，可以使用以下命令（在MBR上）：

\# **grub-install /dev/sda**

**警告**
*GRUB安装不正确可能会让系统的启动顺序失效，所以请小心操作。最好是了解下如何使用dd来备份MBR，并且备份其他已经安装了的GRUB目录，最后确保你有一个应急启动计划。*

####在外部存储设备上安装GRUB

在当前系统之外安装GRUB，你必须在目标设备上手动指定GRUB目录。例如，你的目标设备是/dev/sdc，其根启动文件系统（root/boot）挂载到系统中的/mnt。这表示当你安装GRUB时，你的系统将会在/mnt/boot/grub中找到GRUB文件。你需要在运行grub-install时指定那些文件的位置：

\# **grub-install --boot-directory=/mnt/boot /dev/sdc**

####使用UEFI安装GRUB

使用UEFI安装应该要简单些，你需要做的就是将引导装载程序拷贝到指定的地方。但是你还需要使用efibootmgr命令向固件注册引导装载程序。grub-install命令会运行这个命令，如果它存在的话，理论上说你要做的就是：

\# **grub-install --efi-directory=efi_dir –-bootloader-id=name**

efi_dir是UEFI目录在你的系统中的位置（通常是/boot/efi/efi，因为UEFI分区通常是挂载到/boot/efi上），name是引导装载程序的标识符，我们将在**5.8.2 UEFI启动**中介绍。

遗憾的是，在安装UEFI引导装载程序是会出现很多问题。举个例子，如果你在为另一个系统安装磁盘时，你需要知道如何向系统的固件注册引导装载程序。并且可移动媒体的安装程序也不尽相同。

不过最大的问题还是在于UEFI安全启动。

##5.6 UEFI安全启动的问题

最新出现的Linux安装问题之一是安全启动。这个特性在UEFI中打开时，需要引导装载程序被一个信任的机构进行电子签名。微软要求Windows 8供应商使用安全启动。如果你安装了一个没有被签名过的引导装载程序（目前大多数Linux系统是这样），它将无法启动。

如果你对Windows不感兴趣，可以在EFI设置中关闭安全启动。然而对于双系统计算机来说这可能不是一个好选择。因此Linux系统提供了经过签名的引导装载程序。一些解决方案只不过是GRUB的一个包装，一些则提供完全的、经过签名的加载过程（从引导装载程序一直到内核），还有一些则是全新的引导装载程序（有一些基于efilinux）。

##5.7 链式加载其他操作系统

UEFI使得加载其他操作系统相对容易，因为你可以在EFI分区上安装多个引导装载程序。然而，较老的MBR不支持这个功能，UEFI也不支持，你还是需要一个单独的分区以及MBR引导装载程序。你可以使用chainloading来让GRUB加载和运行指定分区上的不同引导装载程序。

你需要在GRUB配置中新建一个菜单条目（使用**回顾grub.cfg**部分中介绍的方法）。下面是一个在次盘的第三个分区上启动Windows的例子：

menuentry "Windows" {

insmod chain

insmod ntfs

set root=(hd0,3)

chainloader +1

}

选项+1告诉chainloader加载分区上的第一个扇区中的内容。你还可以使用下面的例子加载io.sys MS-DOS加载程序：

menuentry "DOS" {

insmod chain

insmod fat

set root=(hd0,3)

chainloader /io.sys

}

##5.8 引导装载程序细节

现在让我们来看一看引导装载程序的细节。如果你对此没有兴趣，可以跳到下一章。

要理解象GRUB这样的引导装载程序的工作原理，让我们看看你打开计算机时都发生了什么事情。传统计算机启动机制纷繁复杂，有两个主要机制：MBR和UEFI。

###5.8.1 MBR启动

除了我们在**4.1 磁盘设备分区**中介绍的分区信息之外，Master Boot Record（MBR）还有一个441字节大小的区域，BIOS在开机自检（Power-On Self-Test，POST）之后加载其中的内容。然而因为空间太小，无法容纳引导装载程序，所以需要额外的空间，从而就引入了多场景引导装载程序（multi-stage boot loader）。一开始MBR加载引导装载程序的其余部分，通常是在MBR和第一个分区之间。

当然，这样做并不安全，因为上面的代码任何人都可以修改，不过大部分的引导装载程序使用的是这个方式，包括大部分GRUB。另外，这个方式对于GPT分区的磁盘使用BIOS启动不适用，因为GP表信息存放在MBR之后的区域。（为了向后兼容，GPT和传统的MBR分开存储）

GPT的一种临时解决方案时创建一个小分区，称为BIOS启动分区（BIOS boot partition），使用一个特别的UUID作为存放完整启动加载代码的地方。但是GPT通常和UEFI一起使用，而不是BIOS，由此引出了UEFI启动方式。

###5.8.2 UEFI启动

计算机制造商和软件公司意识到传统的BIOS有很多限制，所以他们决定开发一个替代品，这就是可扩展固件接口（Extensible Firmware Interface，EFI）。EFI的普及花了一些时间，现在应用很普遍。目前的标准是统一可扩展固件接口（Unified EFI，UEFI），包括了诸如：内置命令行界面，读取分区表，和浏览文件系统。GPT分区方式ye是UEFI标准的一部分。

UEFI系统的启动过程非常不同，大部分都很容易理解。它不是使用存放在文件系统之外的可执行启动代码，而是使用一种特殊的文件系统叫做EFI系统分区（EFI System Partition, ESP），其中包含一个名为efi的目录。每个引导装载程序有自己的标识符合一个对应的子目录，如：efi/microsoft，efi/apple，和efi/grub。启动加载文件后缀为.efi，和其他支持文件一起存放在这些目录中。

**注解**
*ESP和BIOS启动分区不同，5.8.1 MBR启动中有介绍，UUID也不同。*

你不能将老的引导装载程序代码放到ESP中，因为这些代码是为BIOS接口写的，你必须提供为UEFI编写的引导装载程序代码。例如，在使用GRUB的时候，你必须安装UEFI版本的GRUB，而非BIOS版本的。另外，你必须向固件注册（声明）引导装载程序。

如**5.6 UEFI安全启动的问题**介绍的那样，我们会面临一些安全启动方面的问题。

###5.8.3 GRUB工作原理

让我们来总结一下GRUB，看看它是如何工作的：

1. BIOS或者固件初始化硬件，在启动存储设备上寻找启动代码。
2. BIOS和固件运行找到的启动代码，开始GRUB。
3. 加载GRUB核心。
4. 初始化GRUB核心，此时GRUB可以读取磁盘和文件系统。
5. GRUB识别启动分区，在那里加载配置信息。
6. GRUB为用户提供一个更改配置的机会。
7. 超时或者用户完成操作以后，GRUB执行配置（执行顺序在**5.5.2 GRUB配置**中有介绍）。
8. 执行过程当中，GRUB可能会在启动分区中加载额外的代码（模块）。
9. GRUB执行boot命令，加载和执行配置信息中linux命令指定的内核。

由于计算机系统启动机制各异，步骤3和4会非常复杂。最常见的问题是“GRUB核心在哪里？”，对这个问题有三个可能的答案：

- 部分存储在在MBR和第一个分区起始之间的位置
- 存储在一个常规分区上
- 存储在一个特殊启动分区上，如：GPT启动分区，EFI系统分区（ESP），或者其他地方

除非你有一个ESP，一般情况下BIOS会从MBR加载512字节，这也是GRUB起始的地方。这一小块信息（从GRUB目录中的boot.img演化而来）还不是核心内容，但是它包含核心信息的起始位置，从此处加载核心。

如果你有ESP，GRUB核心则是一个文件。固件可以让ESP找到并且直接执行GRUB核心，或者是其他操作系统的引导装载程序。

对大多数系统来说，上面的内容只是管中窥豹。在加载和运行内核之前，引导装载程序或许还需要加载一个初始的RAM文件系统映像文件到内容。相关内容请看**6.8 初始RAM文件系统**中的initrd配置参数。不过在此之前让我们先了解下一章的内容，用户空间启动。
